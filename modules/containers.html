

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Containers &mdash; LibraryLink Utilities 3.2.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon-32.png"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="LibraryLink Utilities 3.2.0 documentation" href="../index.html"/>
        <link rel="next" title="Error handling" href="error_handling.html"/>
        <link rel="prev" title="Library functions" href="functions.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> LibraryLink Utilities
          

          
            
            <img src="../_static/LLULogo.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                3.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Basic Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic/how_to_use.html">How to use</a></li>
<li class="toctree-l1"><a class="reference external" href="https://wolframresearch.github.io/LibraryLinkUtilities/doxygen/">API reference (Doxygen ↪)</a></li>
</ul>
<p class="caption"><span class="caption-text">Modules</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="functions.html">Library functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Containers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="#raw-containers">Raw Containers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#datastore">DataStore</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mimage">MImage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mnumericarray">MNumericArray</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mtensor">MTensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#msparsearray">MSparseArray</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#generic-wrappers">Generic Wrappers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#llu-genericdatalist"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericDataList</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#llu-genericimage"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericImage</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#llu-genericnumericarray"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericNumericArray</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#llu-generictensor"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericTensor</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#llu-genericsparsearray"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericSparseArray</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#typed-wrappers">Typed Wrappers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#llu-datalist-t"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::DataList&lt;T&gt;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#llu-image-t"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::Image&lt;T&gt;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#llu-numericarray-t"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::NumericArray&lt;T&gt;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#llu-tensor-t"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::Tensor&lt;T&gt;</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#llu-sparsearray-t"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::SparseArray&lt;T&gt;</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#iterators">Iterators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="error_handling.html">Error handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="wstp.html">WSTP support</a></li>
<li class="toctree-l1"><a class="reference internal" href="managed_expressions.html">Managed expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="logger.html">Logging and debug printing</a></li>
<li class="toctree-l1"><a class="reference internal" href="progress_monitor.html">Progress monitor</a></li>
</ul>
<p class="caption"><span class="caption-text">Other Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../other/paclet_use.html">Use in paclets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other/cmake_utilities.html">CMake utility functions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">LibraryLink Utilities</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Containers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="containers">
<h1>Containers<a class="headerlink" href="#containers" title="Permalink to this headline"> 🔗</a></h1>
<p>Raw LibraryLink containers like MTensor or MNumericArray store their element type as a regular field in the structure.
This means that the type cannot be used at compile-time, which makes writing generic code that does something with
the underlying data very difficult (lots of switches on the element type and code repetition).</p>
<p>On the other hand, having the element type as template parameter, like STL containers, is often inconvenient and requires
some template magic for simple things like passing forward the container or reading metadata when the data type is not
known a priori.</p>
<p>To get the best of both worlds and to make the library suitable for different needs, LLU provides two categories of container wrappers -
generic, datatype-agnostic wrappers and full-fledged wrappers templated with the datatype. This is illustrated in the table below:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 35%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>LibraryLink element</p></th>
<th class="head"><p>Generic wrapper</p></th>
<th class="head"><p>Typed wrapper</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#mtensor-label"><span class="std std-ref">MTensor</span></a></p></td>
<td><p><a class="reference internal" href="#generictensor-label"><span class="std std-ref">GenericTensor</span></a></p></td>
<td><p><a class="reference internal" href="#tensor-label"><span class="std std-ref">Tensor&lt;T&gt;</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mnumericarray-label"><span class="std std-ref">MNumericArray</span></a></p></td>
<td><p><a class="reference internal" href="#genericna-label"><span class="std std-ref">GenericNumericArray</span></a></p></td>
<td><p><a class="reference internal" href="#numarr-label"><span class="std std-ref">NumericArray&lt;T&gt;</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mimage-label"><span class="std std-ref">MImage</span></a></p></td>
<td><p><a class="reference internal" href="#genericimg-label"><span class="std std-ref">GenericImage</span></a></p></td>
<td><p><a class="reference internal" href="#image-label"><span class="std std-ref">Image&lt;T&gt;</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#datastore-label"><span class="std std-ref">DataStore</span></a></p></td>
<td><p><a class="reference internal" href="#genericdl-label"><span class="std std-ref">GenericDataList</span></a></p></td>
<td><p><a class="reference internal" href="#datalist-label"><span class="std std-ref">DataList&lt;T&gt;</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#msparsearray-label"><span class="std std-ref">MSparseArray</span></a></p></td>
<td><p><a class="reference internal" href="#genericsa-label"><span class="std std-ref">GenericSparseArray</span></a></p></td>
<td><p><a class="reference internal" href="#spararr-label"><span class="std std-ref">SparseArray&lt;T&gt;</span></a></p></td>
</tr>
</tbody>
</table>
<div class="section" id="memory-management">
<h2>Memory management<a class="headerlink" href="#memory-management" title="Permalink to this headline"> 🔗</a></h2>
<p>When passing a container from Wolfram Language to a C++ library, one of 4 passing modes must be chosen:</p>
<ul class="simple">
<li><p>Automatic</p></li>
<li><p>Constant</p></li>
<li><p>Manual</p></li>
<li><p>Shared</p></li>
</ul>
<p>With the exception of DataStore, which cannot be Constant or Shared.</p>
<p>More about memory management can be found in the
<a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/tutorial/InteractionWithWolframLanguage.html#97446640">LibraryLink documentation</a>.</p>
<p>In plain LibraryLink, the choice you make is reflected only in the Wolfram Language code where <a class="reference external" href="https://reference.wolfram.com/language/ref/LibraryFunctionLoad">LibraryFunctionLoad</a> specifies
the list of parameters for the library function. There is no way to query the WolframLibraryData or MArgument about
the passing modes of function arguments from within C++ code. Therefore, the programmer must remember the passing mode
for each argument and then ensure the correct action is taken (releasing/not releasing memory depending
on the combination of passing mode and whether the container has been returned from the library function to the Wolfram Language).</p>
<p>LLU defines a notion of <em>container ownership</em>:</p>
<dl class="cpp enum">
<dt id="_CPPv4N3LLU9OwnershipE">
<span id="_CPPv3N3LLU9OwnershipE"></span><span id="_CPPv2N3LLU9OwnershipE"></span><span class="target" id="namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadae"></span><em class="property">enum </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Ownership</code><a class="headerlink" href="#_CPPv4N3LLU9OwnershipE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>An enum listing possible owners of a LibraryLink container. </p>
<p>Ownership determines the memory management of a container. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv4N3LLU9Ownership11LibraryLinkE">
<span id="_CPPv3N3LLU9Ownership11LibraryLinkE"></span><span id="_CPPv2N3LLU9Ownership11LibraryLinkE"></span><span class="target" id="namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea288ee6322c093edabf6d391c4ce49484"></span><em class="property">enumerator </em><code class="sig-name descname">LibraryLink</code><a class="headerlink" href="#_CPPv4N3LLU9Ownership11LibraryLinkE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>LibraryLink is responsible for managing the container’s memory. Corresponds to Automatic and “Constant” passing. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N3LLU9Ownership7LibraryE">
<span id="_CPPv3N3LLU9Ownership7LibraryE"></span><span id="_CPPv2N3LLU9Ownership7LibraryE"></span><span class="target" id="namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"></span><em class="property">enumerator </em><code class="sig-name descname">Library</code><a class="headerlink" href="#_CPPv4N3LLU9Ownership7LibraryE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The library (LLU) is responsible for managing the container’s memory. Used for Manual passing and containers created by the library. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N3LLU9Ownership6SharedE">
<span id="_CPPv3N3LLU9Ownership6SharedE"></span><span id="_CPPv2N3LLU9Ownership6SharedE"></span><span class="target" id="namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaeaa6156ea9d66fef24e87e841fbabf7cca"></span><em class="property">enumerator </em><code class="sig-name descname">Shared</code><a class="headerlink" href="#_CPPv4N3LLU9Ownership6SharedE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>When the container is shared LLU only needs to decrease share count when it’s done. Only used for arguments passed as “Shared”. </p>
</dd></dl>

</dd></dl>

<p>LLU ensures that at any point of time every container has a well-defined owner. The ownership is mostly static and may change only on a few occasions e.g.
when passing a container to DataList or setting it as a result of a library function.</p>
<p>When a container is received from the Wolfram Language as an argument to a library function, the developer must inform the <a class="reference internal" href="functions.html#_CPPv4N3LLU16MArgumentManagerE" title="LLU::MArgumentManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MArgumentManager</span></code></a>
about the passing mode used for that container. There is a separate enumeration for this purpose:</p>
<dl class="cpp enum">
<dt id="_CPPv4N3LLU7PassingE">
<span id="_CPPv3N3LLU7PassingE"></span><span id="_CPPv2N3LLU7PassingE"></span><span class="target" id="namespaceLLU_1a3cec82f659ea12a4ad464a4dba7ca4fc"></span><em class="property">enum </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Passing</code><a class="headerlink" href="#_CPPv4N3LLU7PassingE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Enumerated type representing different modes in which a container can be passed from LibraryLink to the library. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/tutorial/InteractionWithWolframLanguage.html#97446640">https://reference.wolfram.com/language/LibraryLink/tutorial/InteractionWithWolframLanguage.html#97446640</a> </p>
</dd>
</dl>
</p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv4N3LLU7Passing9AutomaticE">
<span id="_CPPv3N3LLU7Passing9AutomaticE"></span><span id="_CPPv2N3LLU7Passing9AutomaticE"></span><span class="target" id="namespaceLLU_1a3cec82f659ea12a4ad464a4dba7ca4fca086247a9b57fde6eefee2a0c4752242d"></span><em class="property">enumerator </em><code class="sig-name descname">Automatic</code><a class="headerlink" href="#_CPPv4N3LLU7Passing9AutomaticE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N3LLU7Passing8ConstantE">
<span id="_CPPv3N3LLU7Passing8ConstantE"></span><span id="_CPPv2N3LLU7Passing8ConstantE"></span><span class="target" id="namespaceLLU_1a3cec82f659ea12a4ad464a4dba7ca4fcacb17869fe51048b5a5c4c6106551a255"></span><em class="property">enumerator </em><code class="sig-name descname">Constant</code><a class="headerlink" href="#_CPPv4N3LLU7Passing8ConstantE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N3LLU7Passing6ManualE">
<span id="_CPPv3N3LLU7Passing6ManualE"></span><span id="_CPPv2N3LLU7Passing6ManualE"></span><span class="target" id="namespaceLLU_1a3cec82f659ea12a4ad464a4dba7ca4fcae1ba155a9f2e8c3be94020eef32a0301"></span><em class="property">enumerator </em><code class="sig-name descname">Manual</code><a class="headerlink" href="#_CPPv4N3LLU7Passing6ManualE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv4N3LLU7Passing6SharedE">
<span id="_CPPv3N3LLU7Passing6SharedE"></span><span id="_CPPv2N3LLU7Passing6SharedE"></span><span class="target" id="namespaceLLU_1a3cec82f659ea12a4ad464a4dba7ca4fcaa6156ea9d66fef24e87e841fbabf7cca"></span><em class="property">enumerator </em><code class="sig-name descname">Shared</code><a class="headerlink" href="#_CPPv4N3LLU7Passing6SharedE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">Passing</span></code> value is used by the <a class="reference internal" href="functions.html#_CPPv4N3LLU16MArgumentManagerE" title="LLU::MArgumentManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MArgumentManager</span></code></a> to determine the initial owner of the container.</p>
<p>Here are some examples:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">LLU</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">mint</span><span class="o">&gt;</span> <span class="n">t</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>    <span class="c1">// this Tensor is created (and therefore owned) by the library (LLU)</span>

<span class="n">LLU</span><span class="o">::</span><span class="n">MArgumentManager</span> <span class="n">manager</span> <span class="p">{...};</span>
<span class="k">auto</span> <span class="n">tensor</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getTensor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// tensors acquired via MArgumentManager are by default owned by the LibraryLink</span>

<span class="k">auto</span> <span class="n">image</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getGenericImage</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">Passing</span><span class="o">::</span><span class="n">Shared</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>    <span class="c1">// the image is shared between LLU and the Kernel, so LLU knows not to deallocate</span>
                                                                  <span class="c1">// the underlying MImage when image goes out of scope</span>

<span class="k">auto</span> <span class="n">newImage</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>    <span class="c1">// the newImage has the same contents as image but it is not shared, it is owned by LLU</span>
</pre></div>
</div>
<p>More examples can be found in the unit tests.</p>
</div>
<div class="section" id="raw-containers">
<h2>Raw Containers<a class="headerlink" href="#raw-containers" title="Permalink to this headline"> 🔗</a></h2>
<p>These are just raw LibraryLink containers.</p>
<div class="section" id="datastore">
<span id="datastore-label"></span><h3>DataStore<a class="headerlink" href="#datastore" title="Permalink to this headline"> 🔗</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">DataStore</span></code> is C structure (technically, a pointer to structure) defined in the WolframLibrary. It is a unidirectional linked list of immutable nodes.
Each node consists of a <em>name</em> (<code class="docutils literal notranslate"><span class="pre">char*</span></code>) and <em>value</em> (<code class="docutils literal notranslate"><span class="pre">MArgument</span></code>). DataStore itself can be stored in the MArgument union, which means that DataStores
can be nested. DataStores can be passed to and from library functions. Existing nodes cannot be removed but adding new nodes is supported.</p>
<p>The complete DataStore API can be found inside Wolfram Language (12.0+) installations at  <code class="file docutils literal notranslate"><span class="pre">SystemFiles/IncludeFiles/C/WolframIOLibraryFunctions.h</span></code>.</p>
<p>On the Wolfram Language side a <code class="docutils literal notranslate"><span class="pre">DataStore</span></code> is represented as an expression with head <code class="docutils literal notranslate"><span class="pre">Developer`DataStore</span></code> that takes a list of expressions, where each
expressions is either:</p>
<blockquote>
<div><ul class="simple">
<li><p>a value of type supported by LibraryLink (String, Integer, NumericArray, etc.)</p></li>
<li><p>a <a class="reference external" href="https://reference.wolfram.com/language/ref/Rule">Rule</a> with the LHS being a String and RHS of the form described in the previous point</p></li>
</ul>
</div></blockquote>
<p>For example:</p>
<div class="highlight-wolfram-language notranslate"><div class="highlight"><pre><span></span><span class="nv">Developer`DataStore</span><span class="p">[</span><span class="s">&quot;node_name1&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="m">42</span><span class="p">,</span><span class="w"> </span><span class="nb">NumericArray</span><span class="p">[{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">},</span><span class="w"> </span><span class="s">&quot;Integer8&quot;</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;node_name3&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;node_value3&quot;</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="mimage">
<span id="mimage-label"></span><h3>MImage<a class="headerlink" href="#mimage" title="Permalink to this headline"> 🔗</a></h3>
<p>A structure corresponding to Wolfram Language expressions <a class="reference external" href="https://reference.wolfram.com/language/ref/Image">Image</a> and <a class="reference external" href="https://reference.wolfram.com/language/ref/Image3D">Image3D</a>.
Documented in <a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/tutorial/InteractionWithWolframLanguage.html#441025439">LibraryLink » MImage</a>.</p>
</div>
<div class="section" id="mnumericarray">
<span id="mnumericarray-label"></span><h3>MNumericArray<a class="headerlink" href="#mnumericarray" title="Permalink to this headline"> 🔗</a></h3>
<p>A structure corresponding to Wolfram Language expressions <a class="reference external" href="https://reference.wolfram.com/language/ref/NumericArray">NumericArray</a>.
Documented in <a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/tutorial/InteractionWithWolframLanguage.html#106266186">LibraryLink » MNumericArray</a>.</p>
</div>
<div class="section" id="mtensor">
<span id="mtensor-label"></span><h3>MTensor<a class="headerlink" href="#mtensor" title="Permalink to this headline"> 🔗</a></h3>
<p>A structure corresponding to packed arrays in the Wolfram Language.
Documented in <a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/tutorial/InteractionWithWolframLanguage.html#280210622">LibraryLink » MTensor</a>.</p>
</div>
<div class="section" id="msparsearray">
<span id="msparsearray-label"></span><h3>MSparseArray<a class="headerlink" href="#msparsearray" title="Permalink to this headline"> 🔗</a></h3>
<p>A structure corresponding to Wolfram Language expressions <a class="reference external" href="https://reference.wolfram.com/language/ref/SparseArray">SparseArray</a>.
Documented in <a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/tutorial/InteractionWithWolframLanguage.html#1324196729">LibraryLink » MSparseArray</a>.</p>
</div>
</div>
<div class="section" id="generic-wrappers">
<h2>Generic Wrappers<a class="headerlink" href="#generic-wrappers" title="Permalink to this headline"> 🔗</a></h2>
<p>These are datatype-unaware wrappers that offer automatic memory management and basic interface-like access to metadata (dimensions, rank, etc).
They do not provide direct access to the underlying data except via a <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">void</span><span class="pre">*</span></code> (or via a generic node type <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">LLU::NodeType::Any</span></code> in case of a
GenericDataList).</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>All generic and strongly-typed wrappers are movable but non-copyable, instead they provide a <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">clone</span><span class="pre">(</span><span class="pre">)</span></code> method for performing deep copies.
This is in accordance with rule <a class="reference external" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c67-a-polymorphic-class-should-suppress-copying">C.67</a>
from the C++ Core Guidelines but most of all preventing accidental deep copies of containers is beneficial in terms of performance.</p>
</div>
<div class="section" id="llu-genericdatalist">
<span id="genericdl-label"></span><h3><a class="reference internal" href="#_CPPv4N3LLU15GenericDataListE" title="LLU::GenericDataList"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericDataList</span></code></a><a class="headerlink" href="#llu-genericdatalist" title="Permalink to this headline"> 🔗</a></h3>
<p>GenericDataList is a light-weight wrapper over <a class="reference internal" href="#datastore-label"><span class="std std-ref">DataStore</span></a>. It offers access to the underlying nodes via iterators and a
<a class="reference internal" href="#_CPPv4I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEv1T" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">push_back</span></code></a> method for appending new nodes. You can also get the length of the list.</p>
<p>Here is an example of GenericDataList in action:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* Reverse each string in a list of strings using GenericDataList */</span>
<span class="n">LIBRARY_LINK_FUNCTION</span><span class="p">(</span><span class="n">ReverseStrings</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">MArgumentManager</span> <span class="n">mngr</span> <span class="p">{</span><span class="n">libData</span><span class="p">,</span> <span class="n">Argc</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Res</span><span class="p">};</span>

   <span class="c1">// read the input GenericDataList</span>
   <span class="k">auto</span> <span class="n">dsIn</span> <span class="o">=</span> <span class="n">mngr</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">GenericDataList</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

   <span class="c1">// create new GenericDataList to store reversed strings</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">GenericDataList</span> <span class="n">dsOut</span><span class="p">;</span>

   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">node</span> <span class="p">:</span> <span class="n">dsIn</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// GenericDataList may store nodes of arbitrary type, so we need to explicitly ask to get the string value from the node</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">as</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">UTF8String</span><span class="o">&gt;</span><span class="p">();</span>

      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">reversed</span> <span class="p">{</span><span class="n">s</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">rend</span><span class="p">()};</span>   <span class="c1">// create reversed copy</span>

      <span class="c1">// we push back the reversed string via a string_view, this is safe because GenericDataList will immediately copy the string</span>
      <span class="n">dsOut</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">(</span><span class="n">reversed</span><span class="p">));</span>
   <span class="p">}</span>

   <span class="c1">// set the GenericDataList as the result of the library function</span>
   <span class="n">mngr</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">dsOut</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">LLU</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">NoError</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Technically, GenericDataList is an alias:</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU15GenericDataListE">
<span id="_CPPv3N3LLU15GenericDataListE"></span><span id="_CPPv2N3LLU15GenericDataListE"></span><span class="target" id="namespaceLLU_1a4a9e8e31bf555d15928845a173704aa9"></span><em class="property">using </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">GenericDataList</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType9DataStoreEEE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;">MContainer</a>&lt;MArgumentType::DataStore&gt;<a class="headerlink" href="#_CPPv4N3LLU15GenericDataListE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for DataStore is called GenericDataList. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4IEN3LLU10MContainerIN13MArgumentType9DataStoreEEE">
<span id="_CPPv3IEN3LLU10MContainerIN13MArgumentType9DataStoreEEE"></span><span id="_CPPv2IEN3LLU10MContainerIN13MArgumentType9DataStoreEEE"></span>template&lt;&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">MContainer</code>&lt;MArgumentType::DataStore&gt; : <em class="property">public</em> LLU::MContainerBase&lt;MArgumentType::DataStore&gt;<a class="headerlink" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType9DataStoreEEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for DataStore, provides basic list interface for the underlying raw DataStore. </p>
<p>Subclassed by <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">LLU::DataList&lt; T &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE8iteratorE">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType9DataStoreEE8iteratorE"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType9DataStoreEE8iteratorE"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a1252193a68a7e9731ca179f2c64ca7fa"></span><em class="property">using </em><code class="sig-name descname">iterator</code> = <a class="reference internal" href="#_CPPv4N3LLU17DataStoreIteratorE" title="LLU::DataStoreIterator">DataStoreIterator</a><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE8iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>GenericDataList iterator is <a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a>. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE14const_iteratorE">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType9DataStoreEE14const_iteratorE"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType9DataStoreEE14const_iteratorE"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a84a1091088548b0b71d93ec3536abd51"></span><em class="property">using </em><code class="sig-name descname">const_iterator</code> = <a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE8iteratorE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::iterator">iterator</a><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE14const_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Const iterator over GenericDataList is the same as regular iterator - <a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a>, because it is a proxy iterator. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE9ContainerE">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType9DataStoreEE9ContainerE"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType9DataStoreEE9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE10MContainerEv">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType9DataStoreEE10MContainerEv"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType9DataStoreEE10MContainerEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::MContainer"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a9e8840defd60e5e45d6d9564bfb4e482"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE10MContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default constructor, creates empty DataStore owned by the Library. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE10MContainerE9Container9Ownership">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType9DataStoreEE10MContainerE9Container9Ownership"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType9DataStoreEE10MContainerE9Container9Ownership"></span><span id="LLU::MContainer:MArgumentType::DataStore:::MContainer__Container.Ownership"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a458129c81ba898612c1eb828a87a1a0c"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::Container">Container</a> <em>c</em>, <a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE10MContainerE9Container9Ownership" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create new MContainer wrapping a given raw DataStore. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code>: - a DataStore </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">owner</span></code>: - who manages the memory the raw DataStore </p></li>
</ul>
</dd>
<dt><strong>Note</strong></dt><dd><p>An exception will be thrown if you try to create a Shared DataStore because LibraryLink does not allow for shared DataStores. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE5cloneEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE5cloneEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE5cloneEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::cloneC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a5dff267f16817b137631eae4eca0e5cc"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE10MContainerEv" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::MContainer">MContainer</a> <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this MContainer, performs a deep copy of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned MContainer always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new MContainer, by value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE6lengthEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE6lengthEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE6lengthEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::lengthC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a6fd15ca12397f4ce4532e0a8edc91dad"></span>mint <code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE6lengthEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the length of the DataStore. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>total number of nodes in the DataStore </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE5frontEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE5frontEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE5frontEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::frontC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a52ebe36f1172a8a6c78974829e2c7d42"></span>DataStoreNode <code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE5frontEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the first node of the DataStore. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>first node, if it doesn’t exist the behavior is undefined </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE4backEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE4backEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE4backEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::backC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1ab384d40119d299a88e486359f981e875"></span>DataStoreNode <code class="sig-name descname">back</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE4backEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the last node of the DataStore. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>last node, if it doesn’t exist the behavior is undefined </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE5beginEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE5beginEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE5beginEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::beginC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a4b2eca400b93ee7b746a7ad7fca3b6bc"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE8iteratorE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::iterator">iterator</a> <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE5beginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Proxy iterator to the first element of the DataStore. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE3endEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE3endEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE3endEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::endC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a1d4abfab89c866b8fe29c68425db3de0"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE8iteratorE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::iterator">iterator</a> <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE3endEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Proxy iterator past the last element of the DataStore. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE6cbeginEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE6cbeginEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE6cbeginEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::cbeginC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a919d88a994c83e99379a08c70fd786f7"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE14const_iteratorE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::const_iterator">const_iterator</a> <code class="sig-name descname">cbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE6cbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Proxy iterator to the first element of the DataStore. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE4cendEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE4cendEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE4cendEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::cendC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1ad66163f724cd85d42c8cbdc69c70fa52"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE14const_iteratorE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::const_iterator">const_iterator</a> <code class="sig-name descname">cend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE4cendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Proxy iterator past the last element of the DataStore. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEv1T">
<span id="_CPPv3I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backE1T"></span><span id="_CPPv2I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backE1T"></span>template&lt;typename <code class="sig-name descname">T</code>, EnableIfArgumentType&lt;<a class="reference internal" href="#_CPPv4I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEv1T" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::T">T</a>&gt; = 0&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a3e72734a13ea31aec449dfa4e1d0698f"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEv1T" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::T">T</a> <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEv1T" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new nameless node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: - any valid argument type (either primitive or a wrapper) except for MTensor/MNumericArray </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - value to be moved to the new DataStore node </p></li>
</ul>
</dd>
<dt><strong>Warning</strong></dt><dd><p>MTensor and MNumericArray are actually the same type, so this function cannot handle them correctly as LLU would not be able to figure out which function from the LibraryLink API to call. Use push_back templated with MArgumentType instead. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewE1T">
<span id="_CPPv3I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewE1T"></span><span id="_CPPv2I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewE1T"></span>template&lt;typename <code class="sig-name descname">T</code>, EnableIfArgumentType&lt;<a class="reference internal" href="#_CPPv4I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewE1T" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::T">T</a>&gt; = 0&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1ad26005b349b45d0f5b7aac3c1a0ea2c8"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>std::string_view <em>name</em>, <a class="reference internal" href="#_CPPv4I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewE1T" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::T">T</a> <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0_20EnableIfArgumentTypeI1TEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewE1T" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new named node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: - any valid argument type (either primitive or a wrapper) except for MTensor/MNumericArray </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: - name of the new node, names in a DataStore do not have to be unique </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - value to be moved to the new DataStore node </p></li>
</ul>
</dd>
<dt><strong>Warning</strong></dt><dd><p>MTensor and MNumericArray are actually the same type, so this function cannot handle them correctly as LLU would not be able to figure out which function from the LibraryLink API to call. Use push_back templated with MArgumentType instead. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvN8Argument11WrapperTypeI4TypeEE">
<span id="_CPPv3I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEN8Argument11WrapperTypeI4TypeEE"></span><span id="_CPPv2I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEN8Argument11WrapperTypeI4TypeEE"></span>template&lt;MArgumentType <code class="sig-name descname">Type</code>, EnableIfUnambiguousWrapperType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvN8Argument11WrapperTypeI4TypeEE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::Type">Type</a>&gt; = 0&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1aaee75bd06f7c1ee7e4c20490377d1b54"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>Argument::WrapperType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvN8Argument11WrapperTypeI4TypeEE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::Type">Type</a>&gt; <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvN8Argument11WrapperTypeI4TypeEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new nameless node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span></code>: - type of the node data expressed via the MArgumentType enum </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - a value to be pushed as the new node, must be a wrapper over a primitive LibraryLink type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewEN8Argument11WrapperTypeI4TypeEE">
<span id="_CPPv3I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewEN8Argument11WrapperTypeI4TypeEE"></span><span id="_CPPv2I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewEN8Argument11WrapperTypeI4TypeEE"></span>template&lt;MArgumentType <code class="sig-name descname">Type</code>, EnableIfUnambiguousWrapperType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewEN8Argument11WrapperTypeI4TypeEE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::Type">Type</a>&gt; = 0&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1ad40f40841e383bc5a0efb82980763b4d"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>std::string_view <em>name</em>, Argument::WrapperType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewEN8Argument11WrapperTypeI4TypeEE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::Type">Type</a>&gt; <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewEN8Argument11WrapperTypeI4TypeEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new named node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span></code>: - type of the node data expressed via the MArgumentType enum </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: - name of the new node, names in a DataStore do not have to be unique </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - a value to be pushed as the new node, must be a wrapper over a primitive LibraryLink type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvN8Argument5CTypeI4TypeEE">
<span id="_CPPv3I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEN8Argument5CTypeI4TypeEE"></span><span id="_CPPv2I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEN8Argument5CTypeI4TypeEE"></span>template&lt;MArgumentType <code class="sig-name descname">Type</code>&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a60cdced64960c12dce0971b14e4c4338"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>Argument::CType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvN8Argument5CTypeI4TypeEE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::Type">Type</a>&gt; <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvN8Argument5CTypeI4TypeEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new nameless node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span></code>: - type of the node data expressed via the MArgumentType enum </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - a value to be pushed as the new node, must be of a primitive LibraryLink type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewEN8Argument5CTypeI4TypeEE">
<span id="_CPPv3I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewEN8Argument5CTypeI4TypeEE"></span><span id="_CPPv2I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewEN8Argument5CTypeI4TypeEE"></span>template&lt;MArgumentType <code class="sig-name descname">Type</code>&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1acdd4fcc28e845b06295196f12552b3ff"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>std::string_view <em>name</em>, Argument::CType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewEN8Argument5CTypeI4TypeEE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::push_back::Type">Type</a>&gt; <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_13MArgumentTypeEN3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backEvNSt11string_viewEN8Argument5CTypeI4TypeEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new named node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span></code>: - type of the node data expressed via the MArgumentType enum </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: - name of the new node, names in a DataStore do not have to be unique </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - a value to be pushed as the new node, must be of a primitive LibraryLink type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backERKN8Argument5Typed3AnyE">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backERKN8Argument5Typed3AnyE"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backERKN8Argument5Typed3AnyE"></span><span id="LLU::MContainer:MArgumentType::DataStore:::push_back__Argument::Typed::AnyCR"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1abc1b8dfda081167936403373f112c7f6"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span><em class="property">const</em> Argument::<a class="reference internal" href="#_CPPv4N3LLU8Argument5TypedE" title="LLU::Argument::Typed">Typed</a>::<a class="reference internal" href="#_CPPv4N3LLU8Argument5Typed3AnyE" title="LLU::Argument::Typed::Any">Any</a> &amp;<em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backERKN8Argument5Typed3AnyE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new nameless node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">node</span></code>: - a value to be pushed as the new node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewERKN8Argument5Typed3AnyE">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewERKN8Argument5Typed3AnyE"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewERKN8Argument5Typed3AnyE"></span><span id="LLU::MContainer:MArgumentType::DataStore:::push_back__std::string_view.Argument::Typed::AnyCR"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1acdbe5f0b3173053936b042504f305072"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>std::string_view <em>name</em>, <em class="property">const</em> Argument::<a class="reference internal" href="#_CPPv4N3LLU8Argument5TypedE" title="LLU::Argument::Typed">Typed</a>::<a class="reference internal" href="#_CPPv4N3LLU8Argument5Typed3AnyE" title="LLU::Argument::Typed::Any">Any</a> &amp;<em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE9push_backENSt11string_viewERKN8Argument5Typed3AnyE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new named node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: - name of the new node, names in a DataStore do not have to be unique </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">node</span></code>: - a value to be pushed as the new node, </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE12getContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE12getContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE12getContainerEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE16abandonContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE16abandonContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE16abandonContainerEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType9DataStoreEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE10shareCountEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE10shareCountEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE10shareCountEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE4passER9MArgument">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE4passER9MArgument"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE4passER9MArgument"></span><span id="LLU::MContainer:MArgumentType::DataStore:::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE8getOwnerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType9DataStoreEE8getOwnerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType9DataStoreEE8getOwnerEv"></span><span id="LLU::MContainer:MArgumentType::DataStore:::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="llu-genericimage">
<span id="genericimg-label"></span><h3><a class="reference internal" href="#_CPPv4N3LLU12GenericImageE" title="LLU::GenericImage"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericImage</span></code></a><a class="headerlink" href="#llu-genericimage" title="Permalink to this headline"> 🔗</a></h3>
<p>GenericImage is a light-weight wrapper over <a class="reference internal" href="#mimage-label"><span class="std std-ref">MImage</span></a>. It offers the same API as LibraryLink has for MImage, except for access to the image data,
because GenericImage is not aware of the image data type. Typically one would use GenericImage to take an Image of unknown type from LibraryLink, investigate
image properties and data type and then upgrade the GenericImage to the strongly-typed one in order to perform operations on the image data.</p>
<p>Here is an example of GenericImage in action:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* Get the number of columns in the input Image */</span>
<span class="n">LIBRARY_LINK_FUNCTION</span><span class="p">(</span><span class="n">GetColumnCount</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">MArgumentManager</span> <span class="n">mngr</span> <span class="p">{</span><span class="n">libData</span><span class="p">,</span> <span class="n">Argc</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Res</span><span class="p">};</span>
   <span class="k">const</span> <span class="k">auto</span> <span class="n">image</span> <span class="o">=</span> <span class="n">mngr</span><span class="p">.</span><span class="n">getGenericImage</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">Passing</span><span class="o">::</span><span class="n">Constant</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="n">mngr</span><span class="p">.</span><span class="n">setInteger</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">columns</span><span class="p">());</span>
   <span class="k">return</span> <span class="n">LLU</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">NoError</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<dl class="cpp type">
<dt id="_CPPv4N3LLU12GenericImageE">
<span id="_CPPv3N3LLU12GenericImageE"></span><span id="_CPPv2N3LLU12GenericImageE"></span><span class="target" id="namespaceLLU_1a7013557ff73aaad19a9a5411520be837"></span><em class="property">using </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">GenericImage</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType5ImageEEE" title="LLU::MContainer&lt;MArgumentType::Image&gt;">MContainer</a>&lt;MArgumentType::Image&gt;<a class="headerlink" href="#_CPPv4N3LLU12GenericImageE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for MImage is called GenericImage. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4IEN3LLU10MContainerIN13MArgumentType5ImageEEE">
<span id="_CPPv3IEN3LLU10MContainerIN13MArgumentType5ImageEEE"></span><span id="_CPPv2IEN3LLU10MContainerIN13MArgumentType5ImageEEE"></span>template&lt;&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">MContainer</code>&lt;MArgumentType::Image&gt; : <em class="property">public</em> LLU::ImageInterface, <em class="property">public</em> LLU::MContainerBase&lt;MArgumentType::Image&gt;<a class="headerlink" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType5ImageEEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for MImage. </p>
<p>Subclassed by <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">LLU::Image&lt; T &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE9ContainerE">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType5ImageEE9ContainerE"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType5ImageEE9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerEv">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerEv"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerEv"></span><span id="LLU::MContainer:MArgumentType::Image:::MContainer"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a335020c909103112852417e587a95865"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default constructor, the MContainer does not manage any instance of MImage. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerE4mint4mint4mint11imagedata_t12colorspace_t5mbool">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerE4mint4mint4mint11imagedata_t12colorspace_t5mbool"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerE4mint4mint4mint11imagedata_t12colorspace_t5mbool"></span><span id="LLU::MContainer:MArgumentType::Image:::MContainer__mint.mint.mint.imagedata_t.colorspace_t.mbool"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a6a806a4796743eb91515e8fa57d9c18d"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span>mint <em>width</em>, mint <em>height</em>, mint <em>channels</em>, imagedata_t <em>type</em>, colorspace_t <em>colorSpace</em>, mbool <em>interleaving</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerE4mint4mint4mint11imagedata_t12colorspace_t5mbool" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create new 2D MImage based on given parameters. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">width</span></code>: - image width in pixels (number of columns) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">height</span></code>: - image height in pixels (number of rows) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">channels</span></code>: - number of color channels (for example 3 for RGB, 1 for greyscale) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: - image data type (1-bit, 8-bit, Real32, etc.) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">colorSpace</span></code>: - image color space </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interleaving</span></code>: - whether the image data should be interleaved or not </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerE4mint4mint4mint4mint11imagedata_t12colorspace_t5mbool">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerE4mint4mint4mint4mint11imagedata_t12colorspace_t5mbool"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerE4mint4mint4mint4mint11imagedata_t12colorspace_t5mbool"></span><span id="LLU::MContainer:MArgumentType::Image:::MContainer__mint.mint.mint.mint.imagedata_t.colorspace_t.mbool"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a5dfc2e7a23f00a0d4817ebc0440a7381"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span>mint <em>slices</em>, mint <em>width</em>, mint <em>height</em>, mint <em>channels</em>, imagedata_t <em>type</em>, colorspace_t <em>colorSpace</em>, mbool <em>interleaving</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerE4mint4mint4mint4mint11imagedata_t12colorspace_t5mbool" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create new 2D or 3D MImage based on given parameters. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">slices</span></code>: - number of slices (0 for 2D <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a>, any positive number for Image3D) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">width</span></code>: - image width in pixels (number of columns) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">height</span></code>: - image height in pixels (number of rows) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">channels</span></code>: - number of color channels (for example 3 for RGB, 1 for greyscale) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: - image data type (1-bit, 8-bit, Real32, etc.) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">colorSpace</span></code>: - image color space </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interleaving</span></code>: - whether the image data should be interleaved or not </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7convertE11imagedata_t5mbool">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE7convertE11imagedata_t5mbool"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE7convertE11imagedata_t5mbool"></span><span id="LLU::MContainer:MArgumentType::Image:::convert__imagedata_t.mboolC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a6a64a4d9b550eafe4885af3444366101"></span><a class="reference internal" href="#_CPPv4N3LLU12GenericImageE" title="LLU::GenericImage">GenericImage</a> <code class="sig-name descname">convert</code><span class="sig-paren">(</span>imagedata_t <em>t</em>, mbool <em>interleavingQ</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7convertE11imagedata_t5mbool" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Convert this object to a new GenericImage of given datatype, optionally changing interleaving. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: - destination data type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interleavingQ</span></code>: - whether the converted GenericImage should be interleaved or not </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>converted GenericImage owned by the Library </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_convertType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_convertType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7convertE11imagedata_t">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE7convertE11imagedata_t"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE7convertE11imagedata_t"></span><span id="LLU::MContainer:MArgumentType::Image:::convert__imagedata_tC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a5f2872c0b22afe7218cefa561b392464"></span><a class="reference internal" href="#_CPPv4N3LLU12GenericImageE" title="LLU::GenericImage">GenericImage</a> <code class="sig-name descname">convert</code><span class="sig-paren">(</span>imagedata_t <em>t</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7convertE11imagedata_t" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Convert this object to a new GenericImage of given datatype. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: - destination data type </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>converted GenericImage owned by the Library </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_convertType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_convertType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE5cloneEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE5cloneEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE5cloneEv"></span><span id="LLU::MContainer:MArgumentType::Image:::cloneC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a4d7c5071e2e315c935d699f2dfb3a3f0"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE10MContainerEv" title="LLU::MContainer&lt;MArgumentType::Image&gt;::MContainer">MContainer</a> <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this MContainer, performs a deep copy of the underlying MImage. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned MContainer always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new MContainer, by value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE10colorspaceEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE10colorspaceEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE10colorspaceEv"></span><span id="LLU::MContainer:MArgumentType::Image:::colorspaceC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1afd9d7e2706d763f05e41aafa55b2bd5a"></span>colorspace_t <code class="sig-name descname">colorspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE10colorspaceEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get colorspace which describes how colors are represented as numbers. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getColorSpace.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getColorSpace.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE4rowsEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE4rowsEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE4rowsEv"></span><span id="LLU::MContainer:MArgumentType::Image:::rowsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1ada89917233c80bb6c976462f24ba502f"></span>mint <code class="sig-name descname">rows</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE4rowsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get number of rows. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRowCount.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRowCount.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7columnsEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE7columnsEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE7columnsEv"></span><span id="LLU::MContainer:MArgumentType::Image:::columnsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1aa0dc9cc9b2ef3ed9baf2e6eaabbf8190"></span>mint <code class="sig-name descname">columns</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7columnsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get number of columns. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getColumnCount.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getColumnCount.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE6slicesEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE6slicesEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE6slicesEv"></span><span id="LLU::MContainer:MArgumentType::Image:::slicesC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a4353353b3b1f82ed3be6b9d638dc5449"></span>mint <code class="sig-name descname">slices</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE6slicesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get number of slices. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getSliceCount.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getSliceCount.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE8channelsEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE8channelsEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE8channelsEv"></span><span id="LLU::MContainer:MArgumentType::Image:::channelsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1aa96760718aae476b9d137ae930d4fe20"></span>mint <code class="sig-name descname">channels</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE8channelsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get number of channels. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getChannels.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getChannels.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE13alphaChannelQEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE13alphaChannelQEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE13alphaChannelQEv"></span><span id="LLU::MContainer:MArgumentType::Image:::alphaChannelQC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a9122d4d21578404a9799a0537cb2ad21"></span>bool <code class="sig-name descname">alphaChannelQ</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE13alphaChannelQEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check if there is an alpha channel in the image. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_alphaChannelQ.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_alphaChannelQ.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE12interleavedQEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE12interleavedQEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE12interleavedQEv"></span><span id="LLU::MContainer:MArgumentType::Image:::interleavedQC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1af3639070e4ee43f6b35ca8159f2d4df5"></span>bool <code class="sig-name descname">interleavedQ</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE12interleavedQEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check if the image is interleaved. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_interleavedQ.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_interleavedQ.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE4is3DEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE4is3DEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE4is3DEv"></span><span id="LLU::MContainer:MArgumentType::Image:::is3DC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a3d26e0b815c263c3d2f5ae6cd57f7089"></span>bool <code class="sig-name descname">is3D</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE4is3DEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check if the image is 3D. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7getRankEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE7getRankEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE7getRankEv"></span><span id="LLU::MContainer:MArgumentType::Image:::getRankC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1acb78a7ae597ce55ca0ae1217f2e7cd82"></span>mint <code class="sig-name descname">getRank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7getRankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get rank. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRank.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRank.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE18getFlattenedLengthEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE18getFlattenedLengthEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE18getFlattenedLengthEv"></span><span id="LLU::MContainer:MArgumentType::Image:::getFlattenedLengthC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a73de9b9dda263b83edf03fc01c8e967a"></span>mint <code class="sig-name descname">getFlattenedLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE18getFlattenedLengthEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the total number of pixels in the image. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getFlattenedLength.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getFlattenedLength.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE4typeEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE4typeEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE4typeEv"></span><span id="LLU::MContainer:MArgumentType::Image:::typeC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1acd2311422ab186838cb279478679c7e1"></span>imagedata_t <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the data type of the image. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type of elements (see definition of <code class="docutils literal notranslate"><span class="pre">imagedata_t</span></code>) </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getDataType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getDataType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7rawDataEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE7rawDataEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE7rawDataEv"></span><span id="LLU::MContainer:MArgumentType::Image:::rawDataC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1ab50949e739de8bb66e93f3ca6650db1a"></span>void *<code class="sig-name descname">rawData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE7rawDataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get access to raw image data. </p>
<p>Use with caution. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to the raw data </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRawData.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRawData.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE12getContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE12getContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE12getContainerEv"></span><span id="LLU::MContainer:MArgumentType::Image:::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::Image&gt;::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE16abandonContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE16abandonContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE16abandonContainerEv"></span><span id="LLU::MContainer:MArgumentType::Image:::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType5ImageEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::Image&gt;::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE10shareCountEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE10shareCountEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE10shareCountEv"></span><span id="LLU::MContainer:MArgumentType::Image:::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE4passER9MArgument">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE4passER9MArgument"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE4passER9MArgument"></span><span id="LLU::MContainer:MArgumentType::Image:::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE8getOwnerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType5ImageEE8getOwnerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType5ImageEE8getOwnerEv"></span><span id="LLU::MContainer:MArgumentType::Image:::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType5ImageEE8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="llu-genericnumericarray">
<span id="genericna-label"></span><h3><a class="reference internal" href="#_CPPv4N3LLU19GenericNumericArrayE" title="LLU::GenericNumericArray"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericNumericArray</span></code></a><a class="headerlink" href="#llu-genericnumericarray" title="Permalink to this headline"> 🔗</a></h3>
<p>GenericNumericArray is a light-weight wrapper over <a class="reference internal" href="#mnumericarray-label"><span class="std std-ref">MNumericArray</span></a>. It offers the same API as LibraryLink has for MNumericArray, except for access
to the underlying array data, because GenericNumericArray is not aware of the array data type. Typically on would use GenericNumericArray to take a NumericArray
of unknown type from LibraryLink, investigate its properties and data type and then upgrade the GenericNumericArray to the strongly-typed one in order to
perform operations on the underlying data.</p>
<p>Here is an example of GenericNumericArray in action:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* Return the largest dimension of the input NumericArray */</span>
<span class="n">LIBRARY_LINK_FUNCTION</span><span class="p">(</span><span class="n">GetLargestDimension</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">MArgumentManager</span> <span class="n">mngr</span> <span class="p">{</span><span class="n">libData</span><span class="p">,</span> <span class="n">Argc</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Res</span><span class="p">};</span>
   <span class="k">const</span> <span class="k">auto</span> <span class="n">numericArray</span> <span class="o">=</span> <span class="n">mngr</span><span class="p">.</span><span class="n">getGenericNumericArray</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">Passing</span><span class="o">::</span><span class="n">Constant</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

   <span class="c1">// The list of dimensions of the NumericArray will never be empty because scalar NumericArrays are forbidden</span>
   <span class="k">auto</span> <span class="n">maxDim</span> <span class="o">=</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">max_element</span><span class="p">(</span><span class="n">numericArray</span><span class="p">.</span><span class="n">getDimensions</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">numericArray</span><span class="p">.</span><span class="n">getDimensions</span><span class="p">(),</span> <span class="n">numericArray</span><span class="p">.</span><span class="n">getRank</span><span class="p">()));</span>
   <span class="n">mngr</span><span class="p">.</span><span class="n">setInteger</span><span class="p">(</span><span class="n">maxDim</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">LLU</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">NoError</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<dl class="cpp type">
<dt id="_CPPv4N3LLU19GenericNumericArrayE">
<span id="_CPPv3N3LLU19GenericNumericArrayE"></span><span id="_CPPv2N3LLU19GenericNumericArrayE"></span><span class="target" id="namespaceLLU_1ac246fc9334d25bf0df9d08f0bfb8927d"></span><em class="property">using </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">GenericNumericArray</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType12NumericArrayEEE" title="LLU::MContainer&lt;MArgumentType::NumericArray&gt;">MContainer</a>&lt;MArgumentType::NumericArray&gt;<a class="headerlink" href="#_CPPv4N3LLU19GenericNumericArrayE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for MNumericArray is called GenericNumericArray. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4IEN3LLU10MContainerIN13MArgumentType12NumericArrayEEE">
<span id="_CPPv3IEN3LLU10MContainerIN13MArgumentType12NumericArrayEEE"></span><span id="_CPPv2IEN3LLU10MContainerIN13MArgumentType12NumericArrayEEE"></span>template&lt;&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">MContainer</code>&lt;MArgumentType::NumericArray&gt; : <em class="property">public</em> LLU::NumericArrayInterface, <em class="property">public</em> LLU::MContainerBase&lt;MArgumentType::NumericArray&gt;<a class="headerlink" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType12NumericArrayEEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for MNumericArray. </p>
<p>Subclassed by <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">LLU::NumericArray&lt; T &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType12NumericArrayEE9ContainerE">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType12NumericArrayEE9ContainerE"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType12NumericArrayEE9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType12NumericArrayEE9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType12NumericArrayEE10MContainerEv">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType12NumericArrayEE10MContainerEv"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType12NumericArrayEE10MContainerEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::MContainer"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1ae518e44917084a5777cb00c327de16bc"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType12NumericArrayEE10MContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default constructor, the MContainer does not manage any instance of MNumericArray. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType12NumericArrayEE10MContainerE19numericarray_data_t4mintPK4mint">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType12NumericArrayEE10MContainerE19numericarray_data_t4mintPK4mint"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType12NumericArrayEE10MContainerE19numericarray_data_t4mintPK4mint"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::MContainer__numericarray_data_t.mint.mintCP"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1abd4ef444c2a19317bfdc639f3a536172"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span>numericarray_data_t <em>type</em>, mint <em>rank</em>, <em class="property">const</em> mint *<em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType12NumericArrayEE10MContainerE19numericarray_data_t4mintPK4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create GenericNumericArray of given type and shape. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: - new GenericNumericArray type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rank</span></code>: - new GenericNumericArray rank </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dims</span></code>: - new GenericNumericArray dimensions </p></li>
</ul>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_new.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_new.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7convertE19numericarray_data_tN2NA16ConversionMethodEd">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7convertE19numericarray_data_tN2NA16ConversionMethodEd"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7convertE19numericarray_data_tN2NA16ConversionMethodEd"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::convert__numericarray_data_t.NA::ConversionMethod.doubleC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1a31bd8cf6a865be602b8492738fdbad94"></span><a class="reference internal" href="#_CPPv4N3LLU19GenericNumericArrayE" title="LLU::GenericNumericArray">GenericNumericArray</a> <code class="sig-name descname">convert</code><span class="sig-paren">(</span>numericarray_data_t <em>t</em>, NA::ConversionMethod <em>method</em>, double <em>param</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7convertE19numericarray_data_tN2NA16ConversionMethodEd" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Convert this object to a new GenericNumericArray of given datatype, using specified conversion method. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: - destination data type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>: - conversion method </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">param</span></code>: - conversion method parameter (aka tolerance) </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>converted GenericNumericArray owned by the Library </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_convertType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_convertType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE5cloneEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE5cloneEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE5cloneEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::cloneC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1a3133518d58e2b203f8ab7b1707f7b9dc"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType12NumericArrayEE10MContainerEv" title="LLU::MContainer&lt;MArgumentType::NumericArray&gt;::MContainer">MContainer</a> <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this MContainer, performs a deep copy of the underlying MNumericArray. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned MContainer always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new MContainer, by value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7getRankEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7getRankEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7getRankEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::getRankC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1abbc354b8727bb4769df5e087b34d186c"></span>mint <code class="sig-name descname">getRank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7getRankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get rank. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>number of dimensions in the array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getRank.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getRank.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE13getDimensionsEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE13getDimensionsEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE13getDimensionsEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::getDimensionsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1ab5c213e75fb568c729dbdcdd77acda0f"></span>mint <em class="property">const</em> *<code class="sig-name descname">getDimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE13getDimensionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get dimensions. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>raw pointer to dimensions of the array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getDimensions.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getDimensions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE18getFlattenedLengthEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE18getFlattenedLengthEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE18getFlattenedLengthEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::getFlattenedLengthC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1a8a28c51ced9dee034006ef3ead751060"></span>mint <code class="sig-name descname">getFlattenedLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE18getFlattenedLengthEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get length. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>total number of elements </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getFlattenedLength.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getFlattenedLength.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE4typeEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE4typeEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE4typeEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::typeC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1ab2ef63a6ffa7b34c058daf4ca3303e5a"></span>numericarray_data_t <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the data type of this array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type of elements (see definition of <code class="docutils literal notranslate"><span class="pre">numericarray_data_t</span></code>) </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getDataType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getDataType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7rawDataEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7rawDataEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7rawDataEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::rawDataC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1a71a50a2beea248ba58238e3c0435ac43"></span>void *<code class="sig-name descname">rawData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE7rawDataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get access to the raw data. </p>
<p>Use with caution. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to the raw data </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getData.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getData.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE12getContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE12getContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE12getContainerEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType12NumericArrayEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::NumericArray&gt;::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE16abandonContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE16abandonContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE16abandonContainerEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType12NumericArrayEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::NumericArray&gt;::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE10shareCountEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE10shareCountEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE10shareCountEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE4passER9MArgument">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE4passER9MArgument"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE4passER9MArgument"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE8getOwnerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType12NumericArrayEE8getOwnerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType12NumericArrayEE8getOwnerEv"></span><span id="LLU::MContainer:MArgumentType::NumericArray:::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType12NumericArrayEE8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="llu-generictensor">
<span id="generictensor-label"></span><h3><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericTensor</span></code></a><a class="headerlink" href="#llu-generictensor" title="Permalink to this headline"> 🔗</a></h3>
<p>GenericTensor is a light-weight wrapper over <a class="reference internal" href="#mtensor-label"><span class="std std-ref">MTensor</span></a>. It offers the same API that LibraryLink has for MTensor, except for access
to the underlying array data because GenericTensor is not aware of the array data type. Typically on would use GenericTensor to take a Tensor
of an unknown type from LibraryLink, investigate its properties and data type, then upgrade the GenericTensor to the strongly-typed one in order to
perform operations on the underlying data.</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU13GenericTensorE">
<span id="_CPPv3N3LLU13GenericTensorE"></span><span id="_CPPv2N3LLU13GenericTensorE"></span><span class="target" id="namespaceLLU_1aa463b81b42bbdd7c6fb53e32132e0a2f"></span><em class="property">using </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">GenericTensor</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType6TensorEEE" title="LLU::MContainer&lt;MArgumentType::Tensor&gt;">MContainer</a>&lt;MArgumentType::Tensor&gt;<a class="headerlink" href="#_CPPv4N3LLU13GenericTensorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for MTensor is called GenericTensor. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4IEN3LLU10MContainerIN13MArgumentType6TensorEEE">
<span id="_CPPv3IEN3LLU10MContainerIN13MArgumentType6TensorEEE"></span><span id="_CPPv2IEN3LLU10MContainerIN13MArgumentType6TensorEEE"></span>template&lt;&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">MContainer</code>&lt;MArgumentType::Tensor&gt; : <em class="property">public</em> LLU::TensorInterface, <em class="property">public</em> LLU::MContainerBase&lt;MArgumentType::Tensor&gt;<a class="headerlink" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType6TensorEEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for MTensor. </p>
<p>Subclassed by <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">LLU::Tensor&lt; T &gt;</span></a>, <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">LLU::Tensor&lt; double &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType6TensorEE9ContainerE">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType6TensorEE9ContainerE"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType6TensorEE9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType6TensorEE9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType6TensorEE10MContainerEv">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType6TensorEE10MContainerEv"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType6TensorEE10MContainerEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::MContainer"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1a80616a149ee354f867d65ef0c90766fd"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType6TensorEE10MContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default constructor, the MContainer does not manage any instance of MTensor. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType6TensorEE10MContainerE4mint4mintPK4mint">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType6TensorEE10MContainerE4mint4mintPK4mint"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType6TensorEE10MContainerE4mint4mintPK4mint"></span><span id="LLU::MContainer:MArgumentType::Tensor:::MContainer__mint.mint.mintCP"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1ad5c331a0df4ed70d466ad6c052e6877b"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span>mint <em>type</em>, mint <em>rank</em>, <em class="property">const</em> mint *<em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType6TensorEE10MContainerE4mint4mintPK4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create GenericTensor of given type and shape. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: - new GenericTensor type (MType_Integer, MType_Real or MType_Complex) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rank</span></code>: - new GenericTensor rank </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dims</span></code>: - new GenericTensor dimensions </p></li>
</ul>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_new.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_new.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE5cloneEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE5cloneEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE5cloneEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::cloneC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1ae52529ccbb33067393840c73f76997dd"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType6TensorEE10MContainerEv" title="LLU::MContainer&lt;MArgumentType::Tensor&gt;::MContainer">MContainer</a> <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this MContainer, performs a deep copy of the underlying MTensor. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned MContainer always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new MContainer, by value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE7getRankEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE7getRankEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE7getRankEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::getRankC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1a08e3854d4989119c4bde754ee4e1e98d"></span>mint <code class="sig-name descname">getRank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE7getRankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get rank. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>number of dimensions in this tensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getRank.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getRank.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE13getDimensionsEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE13getDimensionsEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE13getDimensionsEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::getDimensionsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1a60f0ce5f03e79f7fb75f6637e2d22583"></span>mint <em class="property">const</em> *<code class="sig-name descname">getDimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE13getDimensionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get dimensions. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>raw pointer to dimensions of this tensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getDimensions.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getDimensions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE18getFlattenedLengthEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE18getFlattenedLengthEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE18getFlattenedLengthEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::getFlattenedLengthC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1ab9cf6ab9c75cb6e3518107adb08965d8"></span>mint <code class="sig-name descname">getFlattenedLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE18getFlattenedLengthEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get total length. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>total number of elements </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getFlattenedLength.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getFlattenedLength.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE4typeEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE4typeEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE4typeEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::typeC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1a5e5d2ed923a5edcd9301ed3e2fe654ec"></span>mint <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the data type of this tensor. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type of elements (MType_Integer, MType_Real or MType_Complex) </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE7rawDataEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE7rawDataEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE7rawDataEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::rawDataC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1aa5c6718ea36d23638c0ca151f625a3b7"></span>void *<code class="sig-name descname">rawData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE7rawDataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get raw pointer to the data of this tensor. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE12getContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE12getContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE12getContainerEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType6TensorEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::Tensor&gt;::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE16abandonContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE16abandonContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE16abandonContainerEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType6TensorEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::Tensor&gt;::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE10shareCountEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE10shareCountEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE10shareCountEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE4passER9MArgument">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE4passER9MArgument"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE4passER9MArgument"></span><span id="LLU::MContainer:MArgumentType::Tensor:::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE8getOwnerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType6TensorEE8getOwnerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType6TensorEE8getOwnerEv"></span><span id="LLU::MContainer:MArgumentType::Tensor:::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType6TensorEE8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="llu-genericsparsearray">
<span id="genericsa-label"></span><h3><a class="reference internal" href="#_CPPv4N3LLU18GenericSparseArrayE" title="LLU::GenericSparseArray"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">LLU::GenericSparseArray</span></code></a><a class="headerlink" href="#llu-genericsparsearray" title="Permalink to this headline"> 🔗</a></h3>
<p>GenericSparseArray is a light-weight wrapper over <a class="reference internal" href="#msparsearray-label"><span class="std std-ref">MSparseArray</span></a>. It offers the same API that LibraryLink has for MSparseArray, except for access
to the underlying array data because GenericSparseArray is not aware of the array data type. Typically one would use GenericSparseArray to take an MSparseArray
of an unknown type from LibraryLink, investigate its properties and data type, then upgrade the GenericSparseArray to the strongly-typed one in order to
perform operations on the underlying data.</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU18GenericSparseArrayE">
<span id="_CPPv3N3LLU18GenericSparseArrayE"></span><span id="_CPPv2N3LLU18GenericSparseArrayE"></span><span class="target" id="namespaceLLU_1a64e0da42320bd3b51aa4eea7d05bd88a"></span><em class="property">using </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">GenericSparseArray</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType11SparseArrayEEE" title="LLU::MContainer&lt;MArgumentType::SparseArray&gt;">MContainer</a>&lt;MArgumentType::SparseArray&gt;<a class="headerlink" href="#_CPPv4N3LLU18GenericSparseArrayE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for MSparseArray is called GenericSparseArray. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4IEN3LLU10MContainerIN13MArgumentType11SparseArrayEEE">
<span id="_CPPv3IEN3LLU10MContainerIN13MArgumentType11SparseArrayEEE"></span><span id="_CPPv2IEN3LLU10MContainerIN13MArgumentType11SparseArrayEEE"></span>template&lt;&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">MContainer</code>&lt;MArgumentType::SparseArray&gt; : <em class="property">public</em> LLU::MContainerBase&lt;MArgumentType::SparseArray&gt;<a class="headerlink" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType11SparseArrayEEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>MContainer specialization for MSparseArray. </p>
<p>Subclassed by <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">LLU::SparseArray&lt; T &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE9ContainerE">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType11SparseArrayEE9ContainerE"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType11SparseArrayEE9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerEv">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerEv"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::MContainer"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a9db306b54dcaf5926192fc392d10d197"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default constructor, the MContainer does not manage any instance of MSparseArray. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK13GenericTensorRK13GenericTensorRK13GenericTensorRK13GenericTensor">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK13GenericTensorRK13GenericTensorRK13GenericTensorRK13GenericTensor"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK13GenericTensorRK13GenericTensorRK13GenericTensorRK13GenericTensor"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::MContainer__GenericTensorCR.GenericTensorCR.GenericTensorCR.GenericTensorCR"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1aa08ea9c9082c1df771cd1d615a1fef14"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> &amp;<em>positions</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> &amp;<em>values</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> &amp;<em>dimensions</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> &amp;<em>implicitValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK13GenericTensorRK13GenericTensorRK13GenericTensorRK13GenericTensor" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> from positions, values, dimensions and an implicit value. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">positions</span></code>: - positions of all the explicit values in the array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">values</span></code>: - explicit values to be stored in the array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dimensions</span></code>: - dimensions of the new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">implicitValue</span></code>: - implicit value (the one that is not stored) of the new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
</ul>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_fromExplicitPositions.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_fromExplicitPositions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK13GenericTensorRK13GenericTensor">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK13GenericTensorRK13GenericTensor"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK13GenericTensorRK13GenericTensor"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::MContainer__GenericTensorCR.GenericTensorCR"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a4f9b93236f72a28d37cd2bf0071dbe40"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> &amp;<em>data</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> &amp;<em>implicitValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK13GenericTensorRK13GenericTensor" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> from data array and an implicit value. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: - a tensor whose contents will be copied and sparsified </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">implicitValue</span></code>: - implicit value (the one that is not stored) of the new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
</ul>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_fromMTensor.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_fromMTensor.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK18GenericSparseArrayRK13GenericTensor">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK18GenericSparseArrayRK13GenericTensor"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK18GenericSparseArrayRK13GenericTensor"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::MContainer__GenericSparseArrayCR.GenericTensorCR"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1aac84338ef4cab01477c228a06638be83"></span><code class="sig-name descname">MContainer</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU18GenericSparseArrayE" title="LLU::GenericSparseArray">GenericSparseArray</a> &amp;<em>s</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> &amp;<em>implicitValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerERK18GenericSparseArrayRK13GenericTensor" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create a copy of given <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> with different implicit value. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code>: - other <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">implicitValue</span></code>: - implicit value (the one that is not stored) of the new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
</ul>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE5cloneEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE5cloneEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE5cloneEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::cloneC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a7f423c613bec0591ff269abbebe255f5"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10MContainerEv" title="LLU::MContainer&lt;MArgumentType::SparseArray&gt;::MContainer">MContainer</a> <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this MContainer, performs a deep copy of the underlying MSparseArray. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned MContainer always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new MContainer, by value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE24getImplicitValueAsTensorEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE24getImplicitValueAsTensorEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE24getImplicitValueAsTensorEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::getImplicitValueAsTensorC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a9a211070a2972d586240f486f8c733c5"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getImplicitValueAsTensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE24getImplicitValueAsTensorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the implicit value of this sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Rank 0 tensor of the same type as the value type of this sparse array. </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getImplicitValue.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getImplicitValue.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE26setImplicitValueFromTensorERK13GenericTensor">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType11SparseArrayEE26setImplicitValueFromTensorERK13GenericTensor"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType11SparseArrayEE26setImplicitValueFromTensorERK13GenericTensor"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::setImplicitValueFromTensor__GenericTensorCR"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1af4c1d6ed5edb883231438720e1ba684a"></span>void <code class="sig-name descname">setImplicitValueFromTensor</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> &amp;<em>implicitValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE26setImplicitValueFromTensorERK13GenericTensor" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Change the implicit value of this array. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">implicitValue</span></code>: - new implicit value </p></li>
</ul>
</dd>
<dt><strong>Note</strong></dt><dd><p>The underlying MSparseArray object may be replaced in the process. </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE7getRankEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE7getRankEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE7getRankEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::getRankC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a880c657eea250c0077a657b8df2da063"></span>mint <code class="sig-name descname">getRank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE7getRankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the rank (number of dimensions) of this sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the rank of this array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRank.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRank.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE13getDimensionsEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE13getDimensionsEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE13getDimensionsEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::getDimensionsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1abd78772083eaa3e033714248fb872784"></span>mint <em class="property">const</em> *<code class="sig-name descname">getDimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE13getDimensionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get dimensions of this sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a read-only raw array of container dimensions </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getDimensions.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getDimensions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE17getExplicitValuesEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE17getExplicitValuesEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE17getExplicitValuesEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::getExplicitValuesC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a56278e459d84d58ee0efeac1d9c0e5b5"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getExplicitValues</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE17getExplicitValuesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a tensor with the values corresponding to the explicitly stored positions in the sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of rank 1 with length equal to the number of explicit positions in the array or an empty wrapper for “pattern sparse arrays” </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitValues.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitValues.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE14getRowPointersEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE14getRowPointersEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE14getRowPointersEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::getRowPointersC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1ab7089de352a7d13d76b0c494a88755e5"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getRowPointers</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE14getRowPointersEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a row pointer array for this sparse array. </p>
<p>The values returned are the cumulative number of explicitly represented elements for each row, so the values will be non-decreasing. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of rank 1 and integer type or an empty GenericTensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRowPointers.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRowPointers.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE16getColumnIndicesEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE16getColumnIndicesEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE16getColumnIndicesEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::getColumnIndicesC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a690a62b0cd980c2adeb008382b1bae48"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getColumnIndices</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE16getColumnIndicesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the column indices for the explicitly stored positions in this sparse array. </p>
<p>The first dimension of the resulting tensor is the number of explicit positions, and the second dimension is equal to getRank() - 1. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of rank 2 or an empty GenericTensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getColumnIndices.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getColumnIndices.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE20getExplicitPositionsEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE20getExplicitPositionsEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE20getExplicitPositionsEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::getExplicitPositionsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a0fb907eddff087c964f195177a274290"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getExplicitPositions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE20getExplicitPositionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the explicitly specified positions in this sparse array. </p>
<p>The first dimension of the resulting tensor is the number of explicit positions, and the second dimension is equal to getRank(). <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of rank 2 or an empty GenericTensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitPositions.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitPositions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE15toGenericTensorEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE15toGenericTensorEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE15toGenericTensorEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::toGenericTensorC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a87c738ddcd337995d1f68263dc640b13"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">toGenericTensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE15toGenericTensorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Expand this sparse array to a regular tensor. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of the same data type as this array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_toMTensor.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_toMTensor.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10resparsifyEv">
<span id="_CPPv3N3LLU10MContainerIN13MArgumentType11SparseArrayEE10resparsifyEv"></span><span id="_CPPv2N3LLU10MContainerIN13MArgumentType11SparseArrayEE10resparsifyEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::resparsify"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a10184d988f1d276133c24bd86209606d"></span>void <code class="sig-name descname">resparsify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE10resparsifyEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Use current implicit value to recalculate the sparse array after the data has been modified. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE4typeEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE4typeEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE4typeEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::typeC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a88f859c1e4dcc265f658f3bb7ad884c3"></span>mint <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the data type of this MSparseArray. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type of elements (MType_Integer, MType_Real or MType_Complex) </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE12getContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE12getContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE12getContainerEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::SparseArray&gt;::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE16abandonContainerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE16abandonContainerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE16abandonContainerEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU10MContainerIN13MArgumentType11SparseArrayEE9ContainerE" title="LLU::MContainer&lt;MArgumentType::SparseArray&gt;::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE10shareCountEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE10shareCountEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE10shareCountEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE4passER9MArgument">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE4passER9MArgument"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE4passER9MArgument"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE8getOwnerEv">
<span id="_CPPv3NK3LLU10MContainerIN13MArgumentType11SparseArrayEE8getOwnerEv"></span><span id="_CPPv2NK3LLU10MContainerIN13MArgumentType11SparseArrayEE8getOwnerEv"></span><span id="LLU::MContainer:MArgumentType::SparseArray:::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType11SparseArrayEE8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="typed-wrappers">
<h2>Typed Wrappers<a class="headerlink" href="#typed-wrappers" title="Permalink to this headline"> 🔗</a></h2>
<p>Typed wrappers are full-fledged wrappers with automatic memory management (see section below), type-safe data access, iterators, etc.
All typed wrappers are movable but non-copyable, instead they provide a <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">clone</span><span class="pre">(</span><span class="pre">)</span></code> method for performing deep copies.</p>
<div class="section" id="llu-datalist-t">
<span id="datalist-label"></span><h3><a class="reference internal" href="#_CPPv4I0EN3LLU8DataListE" title="LLU::DataList"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::DataList&lt;T&gt;</span></code></a><a class="headerlink" href="#llu-datalist-t" title="Permalink to this headline"> 🔗</a></h3>
<p>DataList is a strongly-typed wrapper derived from GenericDataList in which all nodes must be of the same type and be known at compile time. Template parameter
<code class="docutils literal notranslate"><span class="pre">T</span></code> denotes the value type of nodes. Supported node value types are shown below with corresponding types of raw DataStore nodes and with underlying C++ types:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 35%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Node Type Name</p></th>
<th class="head"><p>Underlying Type</p></th>
<th class="head"><p>Raw DataStoreNode Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NodeType::Boolean</p></td>
<td><p>bool</p></td>
<td><p>mbool</p></td>
</tr>
<tr class="row-odd"><td><p>NodeType::Integer</p></td>
<td><p>mint</p></td>
<td><p>mint</p></td>
</tr>
<tr class="row-even"><td><p>NodeType::Real</p></td>
<td><p>double</p></td>
<td><p>mreal</p></td>
</tr>
<tr class="row-odd"><td><p>NodeType::Complex</p></td>
<td><p>std::complex&lt;double&gt;</p></td>
<td><p>mcomplex</p></td>
</tr>
<tr class="row-even"><td><p>NodeType::Tensor</p></td>
<td><p>LLU::GenericTensor</p></td>
<td><p>MTensor</p></td>
</tr>
<tr class="row-odd"><td><p>NodeType::SparseArray</p></td>
<td><p>LLU::GenericSparseArray</p></td>
<td><p>MSparseArray</p></td>
</tr>
<tr class="row-even"><td><p>NodeType::NumericArray</p></td>
<td><p>LLU::GenericNumericArray</p></td>
<td><p>MNumericArray</p></td>
</tr>
<tr class="row-odd"><td><p>NodeType::Image</p></td>
<td><p>LLU::GenericImage</p></td>
<td><p>MImage</p></td>
</tr>
<tr class="row-even"><td><p>NodeType::UTF8String</p></td>
<td><p>std::string_view</p></td>
<td><p>char*</p></td>
</tr>
<tr class="row-odd"><td><p>NodeType::DataStore</p></td>
<td><p>LLU::GenericDataList</p></td>
<td><p>DataStore</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">LLU::NodeType</span></code> is a namespace alias for <code class="docutils literal notranslate"><span class="pre">LLU::Argument::Typed</span></code> which is defined as follows:</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5TypedE">
<span id="_CPPv3N3LLU8Argument5TypedE"></span><span id="_CPPv2N3LLU8Argument5TypedE"></span><span id="LLU::Argument::Typed"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed"></span><em class="property">namespace </em><code class="sig-prename descclassname">LLU::Argument<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Typed</code><a class="headerlink" href="#_CPPv4N3LLU8Argument5TypedE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Namespace defining C++ types corresponding to primitive LibraryLink argument types. </p>
<p>Mainly used for node types in <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed7BooleanE">
<span id="_CPPv3N3LLU8Argument5Typed7BooleanE"></span><span id="_CPPv2N3LLU8Argument5Typed7BooleanE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1a161161a5469ac96e3c6f57339078fd99"></span><em class="property">using </em><code class="sig-name descname">Boolean</code> = bool<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed7BooleanE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Boolean type, corresponds to True or False in the Wolfram Language. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed7IntegerE">
<span id="_CPPv3N3LLU8Argument5Typed7IntegerE"></span><span id="_CPPv2N3LLU8Argument5Typed7IntegerE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1a9fa710c232e9cadf9928b157354a1184"></span><em class="property">using </em><code class="sig-name descname">Integer</code> = mint<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed7IntegerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Machine integer type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed4RealE">
<span id="_CPPv3N3LLU8Argument5Typed4RealE"></span><span id="_CPPv2N3LLU8Argument5Typed4RealE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1ab787afdb5c0bc574c6b412627248b893"></span><em class="property">using </em><code class="sig-name descname">Real</code> = double<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed4RealE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Double precision floating point type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed7ComplexE">
<span id="_CPPv3N3LLU8Argument5Typed7ComplexE"></span><span id="_CPPv2N3LLU8Argument5Typed7ComplexE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1a70c29cd06b12796d53c01b1a7acb40de"></span><em class="property">using </em><code class="sig-name descname">Complex</code> = std::complex&lt;double&gt;<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed7ComplexE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Complex number type, bitwise-compatible with mcomplex defined in WolframLibrary.h. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed6TensorE">
<span id="_CPPv3N3LLU8Argument5Typed6TensorE"></span><span id="_CPPv2N3LLU8Argument5Typed6TensorE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1aeffa52a1d8a48020a7a01c5198a4be09"></span><em class="property">using </em><code class="sig-name descname">Tensor</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType6TensorEEE" title="LLU::MContainer&lt;MArgumentType::Tensor&gt;">MContainer</a>&lt;MArgumentType::Tensor&gt;<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed6TensorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p><a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> stands for a GenericTensor - type agnostic wrapper over MTensor. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed11SparseArrayE">
<span id="_CPPv3N3LLU8Argument5Typed11SparseArrayE"></span><span id="_CPPv2N3LLU8Argument5Typed11SparseArrayE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1ad486922a4bedb428470920418ab6ea62"></span><em class="property">using </em><code class="sig-name descname">SparseArray</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType11SparseArrayEEE" title="LLU::MContainer&lt;MArgumentType::SparseArray&gt;">MContainer</a>&lt;MArgumentType::SparseArray&gt;<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed11SparseArrayE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p><a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> stands for a GenericSparseArray - type agnostic wrapper over MSparseArray. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed12NumericArrayE">
<span id="_CPPv3N3LLU8Argument5Typed12NumericArrayE"></span><span id="_CPPv2N3LLU8Argument5Typed12NumericArrayE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1a827f4e6be86ad6ca6f2a3247fde499f6"></span><em class="property">using </em><code class="sig-name descname">NumericArray</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType12NumericArrayEEE" title="LLU::MContainer&lt;MArgumentType::NumericArray&gt;">MContainer</a>&lt;MArgumentType::NumericArray&gt;<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed12NumericArrayE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p><a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> stands for a GenericNumericArray - type agnostic wrapper over MNumericArray. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed5ImageE">
<span id="_CPPv3N3LLU8Argument5Typed5ImageE"></span><span id="_CPPv2N3LLU8Argument5Typed5ImageE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1a510dcacca0985b36b834da190feee658"></span><em class="property">using </em><code class="sig-name descname">Image</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType5ImageEEE" title="LLU::MContainer&lt;MArgumentType::Image&gt;">MContainer</a>&lt;MArgumentType::Image&gt;<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed5ImageE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p><a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> stands for a GenericImage - type agnostic wrapper over MImage. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed10UTF8StringE">
<span id="_CPPv3N3LLU8Argument5Typed10UTF8StringE"></span><span id="_CPPv2N3LLU8Argument5Typed10UTF8StringE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1a10ae7a1d6a19b6e4fe6f843b14b2b51a"></span><em class="property">using </em><code class="sig-name descname">UTF8String</code> = std::string_view<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed10UTF8StringE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>String values from LibraryLink (char*) are wrapped in std::string_view. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed9DataStoreE">
<span id="_CPPv3N3LLU8Argument5Typed9DataStoreE"></span><span id="_CPPv2N3LLU8Argument5Typed9DataStoreE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1a5104911493a077a9c734c28492cdf69c"></span><em class="property">using </em><code class="sig-name descname">DataStore</code> = <a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType9DataStoreEEE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;">MContainer</a>&lt;MArgumentType::DataStore&gt;<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed9DataStoreE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>DataStore stands for a GenericDataList - type agnostic wrapper over DataStore. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8Argument5Typed3AnyE">
<span id="_CPPv3N3LLU8Argument5Typed3AnyE"></span><span id="_CPPv2N3LLU8Argument5Typed3AnyE"></span><span class="target" id="namespaceLLU_1_1Argument_1_1Typed_1add127175056d668be45ba479a00b6aca"></span><em class="property">using </em><code class="sig-name descname">Any</code> = TypedArgument<a class="headerlink" href="#_CPPv4N3LLU8Argument5Typed3AnyE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Any is a union of all supported types. <a class="reference internal" href="#namespaceLLU_1_1Argument_1_1Typed_1add127175056d668be45ba479a00b6aca"><span class="std std-ref">Typed::Any</span></a> can be used as a template parameter for <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> to get a heterogeneous <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a>. </p>
</dd></dl>

</div>
</dd></dl>

<p>Notice that <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">LLU</span><span class="pre">::</span><span class="pre">NodeType</span><span class="pre">::</span><span class="pre">Any</span></code> (or equivalently <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">LLU</span><span class="pre">::</span><span class="pre">Argument</span><span class="pre">::</span><a class="reference internal" href="#_CPPv4N3LLU8Argument5TypedE" title="LLU::Argument::Typed"><span class="pre">Typed</span></a><span class="pre">::</span><a class="reference internal" href="#_CPPv4N3LLU8Argument5Typed3AnyE" title="LLU::Argument::Typed::Any"><span class="pre">Any</span></a></code>) is a special type which is a union of all other types
from its namespace. In a way it corresponds to <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">MArgument</span></code> type in LibraryLink. A DataList with node type <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">LLU</span><span class="pre">::</span><span class="pre">NodeType</span><span class="pre">::</span><span class="pre">Any</span></code> can store
nodes of any types so it is quite similar to <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">LLU</span><span class="pre">::</span><a class="reference internal" href="#_CPPv4N3LLU15GenericDataListE" title="LLU::GenericDataList"><span class="pre">GenericDataList</span></a></code> but it has the interface of DataList, meaning that it offers more advanced
iterators and more constructors.</p>
<p>Here is an example of the DataList class in action:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* Take a list of named nodes with complex numbers and create two new lists: a list of node names and a list of node values */</span>
<span class="n">LIBRARY_LINK_FUNCTION</span><span class="p">(</span><span class="n">SeparateKeysAndValues</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">MArgumentManager</span> <span class="n">mngr</span> <span class="p">{</span><span class="n">libData</span><span class="p">,</span> <span class="n">Argc</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Res</span><span class="p">};</span>

   <span class="k">auto</span> <span class="n">dsIn</span> <span class="o">=</span> <span class="n">mngr</span><span class="p">.</span><span class="n">getDataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">Complex</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">DataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">UTF8String</span><span class="o">&gt;</span> <span class="n">keys</span><span class="p">;</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">DataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">Complex</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>

   <span class="c1">// For each node in the input DataList push its name to &quot;keys&quot; and its value to &quot;values&quot;</span>
   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">:</span> <span class="n">dsIn</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">keys</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
     <span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="n">LLU</span><span class="o">::</span><span class="n">DataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">GenericDataList</span><span class="o">&gt;</span> <span class="n">dsOut</span><span class="p">;</span>
   <span class="n">dsOut</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Keys&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">keys</span><span class="p">));</span>
   <span class="n">dsOut</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Values&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">values</span><span class="p">));</span>

   <span class="n">mngr</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">dsOut</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">LLU</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">NoError</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>On the Wolfram Language side, we can load and use this function as follows:</p>
<div class="highlight-wolfram-language notranslate"><div class="highlight"><pre><span></span><span class="nv">`LLU`PacletFunctionSet</span><span class="p">[</span><span class="nv">SeparateKeysAndValues</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SeparateKeysAndValues&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;DataStore&quot;</span><span class="p">},</span><span class="w"> </span><span class="s">&quot;DataStore&quot;</span><span class="p">]</span><span class="o">;</span><span class="w"></span>

<span class="nv">SeparateKeysAndValues</span><span class="p">[</span><span class="nv">Developer`DataStore</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">2.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">I</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">-</span><span class="m">3.</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">6.</span><span class="nb">I</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="nb">I</span><span class="p">]]</span><span class="w"></span>

<span class="c">(* Out[] = Developer`DataStore[&quot;Keys&quot; -&gt; Developer`DataStore[&quot;a&quot;, &quot;b&quot;, &quot;&quot;], &quot;Values&quot; -&gt; Developer`DataStore[1. + 2.5 * I, -3. - 6.I, 2.I]] *)</span><span class="w"></span>
</pre></div>
</div>
<dl class="cpp class">
<dt id="_CPPv4I0EN3LLU8DataListE">
<span id="_CPPv3I0EN3LLU8DataListE"></span><span id="_CPPv2I0EN3LLU8DataListE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classLLU_1_1DataList"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">DataList</code> : <em class="property">public</em> LLU::<a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType9DataStoreEEE" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;">MContainer</a>&lt;MArgumentType::DataStore&gt;<a class="headerlink" href="#_CPPv4I0EN3LLU8DataListE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Top-level wrapper over LibraryLink’s DataStore. </p>
<p>Designed to be strongly typed i.e. to wrap only homogeneous DataStores but by passing NodeType::Any as template parameter it will work with arbitrary DataStores. <dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: - type of data stored in each node, see the <code class="docutils literal notranslate"><span class="pre">NodeType</span></code> namespace for possible node types </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU8DataList8iteratorE">
<span id="_CPPv3N3LLU8DataList8iteratorE"></span><span id="_CPPv2N3LLU8DataList8iteratorE"></span><span class="target" id="classLLU_1_1DataList_1af94cb62f4e36b94c99a3b5487e9bc533"></span><em class="property">using </em><code class="sig-name descname">iterator</code> = <a class="reference internal" href="#_CPPv4I0EN3LLU12NodeIteratorE" title="LLU::NodeIterator">NodeIterator</a>&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU8DataListE" title="LLU::DataList::T">T</a>&gt;<a class="headerlink" href="#_CPPv4N3LLU8DataList8iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> iterator is NodeIterator&lt;T&gt; </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8DataList14const_iteratorE">
<span id="_CPPv3N3LLU8DataList14const_iteratorE"></span><span id="_CPPv2N3LLU8DataList14const_iteratorE"></span><span class="target" id="classLLU_1_1DataList_1a3958d41efac68265e56626b76541c994"></span><em class="property">using </em><code class="sig-name descname">const_iterator</code> = <a class="reference internal" href="#_CPPv4N3LLU8DataList8iteratorE" title="LLU::DataList::iterator">iterator</a><a class="headerlink" href="#_CPPv4N3LLU8DataList14const_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>All <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> iterators are proxy iterators so in a way they are all const, therefore <code class="docutils literal notranslate"><span class="pre">const_iterator</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">iterator</span></code>. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8DataList14value_iteratorE">
<span id="_CPPv3N3LLU8DataList14value_iteratorE"></span><span id="_CPPv2N3LLU8DataList14value_iteratorE"></span><span class="target" id="classLLU_1_1DataList_1aa9a7c9d8b5e1b22f49e9559a0f3519ac"></span><em class="property">using </em><code class="sig-name descname">value_iterator</code> = NodeValueIterator&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU8DataListE" title="LLU::DataList::T">T</a>&gt;<a class="headerlink" href="#_CPPv4N3LLU8DataList14value_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>To iterate over node values use a proxy iterator NodeValueIterator&lt;T&gt; </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8DataList13name_iteratorE">
<span id="_CPPv3N3LLU8DataList13name_iteratorE"></span><span id="_CPPv2N3LLU8DataList13name_iteratorE"></span><span class="target" id="classLLU_1_1DataList_1aa57925f0f8cac940a1496fb1ad006346"></span><em class="property">using </em><code class="sig-name descname">name_iterator</code> = NodeNameIterator<a class="headerlink" href="#_CPPv4N3LLU8DataList13name_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>To iterate over node names use a proxy iterator NodeNameIterator. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8DataList10value_typeE">
<span id="_CPPv3N3LLU8DataList10value_typeE"></span><span id="_CPPv2N3LLU8DataList10value_typeE"></span><span class="target" id="classLLU_1_1DataList_1adef3ac6af9687b5af78753c2ba993b9d"></span><em class="property">using </em><code class="sig-name descname">value_type</code> = <a class="reference internal" href="#_CPPv4I0EN3LLU8DataListE" title="LLU::DataList::T">T</a><a class="headerlink" href="#_CPPv4N3LLU8DataList10value_typeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Value of a node is of type T. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU8DataList9ContainerE">
<span id="_CPPv3N3LLU8DataList9ContainerE"></span><span id="_CPPv2N3LLU8DataList9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU8DataList9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataList8DataListE15GenericDataList">
<span id="_CPPv3N3LLU8DataList8DataListE15GenericDataList"></span><span id="_CPPv2N3LLU8DataList8DataListE15GenericDataList"></span><span id="LLU::DataList::DataList__GenericDataList"></span><span class="target" id="classLLU_1_1DataList_1a750db452ee94e17521ab020c094eaa4e"></span><code class="sig-name descname">DataList</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N3LLU15GenericDataListE" title="LLU::GenericDataList">GenericDataList</a> <em>gds</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataList8DataListE15GenericDataList" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> wrapping around an existing GenericDataList. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gds</span></code>: - GenericDataList </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataList8DataListENSt16initializer_listI10value_typeEE">
<span id="_CPPv3N3LLU8DataList8DataListENSt16initializer_listI10value_typeEE"></span><span id="_CPPv2N3LLU8DataList8DataListENSt16initializer_listI10value_typeEE"></span><span id="LLU::DataList::DataList__std::initializer_list:value_type:"></span><span class="target" id="classLLU_1_1DataList_1ad80401f8827c141e07517e06db85aab1"></span><code class="sig-name descname">DataList</code><span class="sig-paren">(</span>std::initializer_list&lt;<a class="reference internal" href="#_CPPv4N3LLU8DataList10value_typeE" title="LLU::DataList::value_type">value_type</a>&gt; <em>initList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataList8DataListENSt16initializer_listI10value_typeEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> from list of values. </p>
<p>Keys will be set to empty strings. <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initList</span></code>: - list of values to put in the <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> </p></li>
</ul>
</dd>
<dt><strong>Note</strong></dt><dd><p>This constructor can only be used if value_type is copyable. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataList8DataListENSt16initializer_listINSt4pairINSt6stringE10value_typeEEEE">
<span id="_CPPv3N3LLU8DataList8DataListENSt16initializer_listINSt4pairINSt6stringE10value_typeEEEE"></span><span id="_CPPv2N3LLU8DataList8DataListENSt16initializer_listINSt4pairINSt6stringE10value_typeEEEE"></span><span id="LLU::DataList::DataList__std::initializer_list:std::pair:ss.value_type::"></span><span class="target" id="classLLU_1_1DataList_1a1e08a4e16b6880e21670a74f2b875361"></span><code class="sig-name descname">DataList</code><span class="sig-paren">(</span>std::initializer_list&lt;std::pair&lt;std::string, <a class="reference internal" href="#_CPPv4N3LLU8DataList10value_typeE" title="LLU::DataList::value_type">value_type</a>&gt;&gt; <em>initList</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataList8DataListENSt16initializer_listINSt4pairINSt6stringE10value_typeEEEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> from list of keys and corresponding values. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initList</span></code>: - list of pairs key - value to put in the <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> </p></li>
</ul>
</dd>
<dt><strong>Note</strong></dt><dd><p>This constructor can only be used if value_type is copyable. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList5cloneEv">
<span id="_CPPv3NK3LLU8DataList5cloneEv"></span><span id="_CPPv2NK3LLU8DataList5cloneEv"></span><span id="LLU::DataList::cloneC"></span><span class="target" id="classLLU_1_1DataList_1ab513a9b2e8d81b14907fe5f3ca61d6ca"></span><a class="reference internal" href="#_CPPv4I0EN3LLU8DataListE" title="LLU::DataList">DataList</a> <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a>, performing a deep copy of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned DataStore always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList5beginEv">
<span id="_CPPv3NK3LLU8DataList5beginEv"></span><span id="_CPPv2NK3LLU8DataList5beginEv"></span><span id="LLU::DataList::beginC"></span><span class="target" id="classLLU_1_1DataList_1ad60cba5e816afccfac6f40dcbc8d00eb"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList8iteratorE" title="LLU::DataList::iterator">iterator</a> <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList5beginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList6cbeginEv">
<span id="_CPPv3NK3LLU8DataList6cbeginEv"></span><span id="_CPPv2NK3LLU8DataList6cbeginEv"></span><span id="LLU::DataList::cbeginC"></span><span class="target" id="classLLU_1_1DataList_1a6283cd3e5bd9100b5b2b56b858e4d728"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList14const_iteratorE" title="LLU::DataList::const_iterator">const_iterator</a> <code class="sig-name descname">cbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList6cbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList3endEv">
<span id="_CPPv3NK3LLU8DataList3endEv"></span><span id="_CPPv2NK3LLU8DataList3endEv"></span><span id="LLU::DataList::endC"></span><span class="target" id="classLLU_1_1DataList_1a72cb3143d8b4a52f1cd0d0862d6009c5"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList8iteratorE" title="LLU::DataList::iterator">iterator</a> <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList3endEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList4cendEv">
<span id="_CPPv3NK3LLU8DataList4cendEv"></span><span id="_CPPv2NK3LLU8DataList4cendEv"></span><span id="LLU::DataList::cendC"></span><span class="target" id="classLLU_1_1DataList_1a02e4959b57a1bcd24db1598e6cdd1e46"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList14const_iteratorE" title="LLU::DataList::const_iterator">const_iterator</a> <code class="sig-name descname">cend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList4cendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant reverse iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList10valueBeginEv">
<span id="_CPPv3NK3LLU8DataList10valueBeginEv"></span><span id="_CPPv2NK3LLU8DataList10valueBeginEv"></span><span id="LLU::DataList::valueBeginC"></span><span class="target" id="classLLU_1_1DataList_1a2ee556221500f0fa15760293a0a9ecbe"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList14value_iteratorE" title="LLU::DataList::value_iterator">value_iterator</a> <code class="sig-name descname">valueBegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList10valueBeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get proxy iterator over node values pointing to the first node. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList8valueEndEv">
<span id="_CPPv3NK3LLU8DataList8valueEndEv"></span><span id="_CPPv2NK3LLU8DataList8valueEndEv"></span><span id="LLU::DataList::valueEndC"></span><span class="target" id="classLLU_1_1DataList_1a3c85cbd33305d321148f329d1d9bdf57"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList14value_iteratorE" title="LLU::DataList::value_iterator">value_iterator</a> <code class="sig-name descname">valueEnd</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList8valueEndEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get proxy iterator over node values pointing past the last node. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList9nameBeginEv">
<span id="_CPPv3NK3LLU8DataList9nameBeginEv"></span><span id="_CPPv2NK3LLU8DataList9nameBeginEv"></span><span id="LLU::DataList::nameBeginC"></span><span class="target" id="classLLU_1_1DataList_1aff6a3689f28cc3e0dde08bc2347f3754"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList13name_iteratorE" title="LLU::DataList::name_iterator">name_iterator</a> <code class="sig-name descname">nameBegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList9nameBeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get proxy iterator over node names (keys) pointing to the first node. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList7nameEndEv">
<span id="_CPPv3NK3LLU8DataList7nameEndEv"></span><span id="_CPPv2NK3LLU8DataList7nameEndEv"></span><span id="LLU::DataList::nameEndC"></span><span class="target" id="classLLU_1_1DataList_1a7fc298291a5344565688e30c5ac93c13"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList13name_iteratorE" title="LLU::DataList::name_iterator">name_iterator</a> <code class="sig-name descname">nameEnd</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList7nameEndEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get proxy iterator over node names (keys) pointing past the last node. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataList9push_backE10value_type">
<span id="_CPPv3N3LLU8DataList9push_backE10value_type"></span><span id="_CPPv2N3LLU8DataList9push_backE10value_type"></span><span id="LLU::DataList::push_back__value_type"></span><span class="target" id="classLLU_1_1DataList_1a316a048d90c0c71e6629489edd9aa031"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N3LLU8DataList10value_typeE" title="LLU::DataList::value_type">value_type</a> <em>nodeData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataList9push_backE10value_type" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new node to the <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a>. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nodeData</span></code>: - actual data to store in the new node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataList9push_backENSt11string_viewE10value_type">
<span id="_CPPv3N3LLU8DataList9push_backENSt11string_viewE10value_type"></span><span id="_CPPv2N3LLU8DataList9push_backENSt11string_viewE10value_type"></span><span id="LLU::DataList::push_back__std::string_view.value_type"></span><span class="target" id="classLLU_1_1DataList_1a92282c9a8fd5ce7fe93e89a6f8a16ced"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>std::string_view <em>name</em>, <a class="reference internal" href="#_CPPv4N3LLU8DataList10value_typeE" title="LLU::DataList::value_type">value_type</a> <em>nodeData</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataList9push_backENSt11string_viewE10value_type" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new named node to the <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a>. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: - name for the new node </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodeData</span></code>: - actual data to store in the new node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList6valuesEv">
<span id="_CPPv3NK3LLU8DataList6valuesEv"></span><span id="_CPPv2NK3LLU8DataList6valuesEv"></span><span id="LLU::DataList::valuesC"></span><span class="target" id="classLLU_1_1DataList_1aa6d95ac7eaeab1cc07e26208db9e7331"></span>std::vector&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU8DataListE" title="LLU::DataList::T">T</a>&gt; <code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList6valuesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return a vector of <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> node values. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a std::vector of node values </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList5namesEv">
<span id="_CPPv3NK3LLU8DataList5namesEv"></span><span id="_CPPv2NK3LLU8DataList5namesEv"></span><span id="LLU::DataList::namesC"></span><span class="target" id="classLLU_1_1DataList_1a243c148cd86546c2c5ad7fc8353ee390"></span>std::vector&lt;std::string&gt; <code class="sig-name descname">names</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList5namesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return a vector of <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> node names. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a std::vector of node names </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList8toVectorEv">
<span id="_CPPv3NK3LLU8DataList8toVectorEv"></span><span id="_CPPv2NK3LLU8DataList8toVectorEv"></span><span id="LLU::DataList::toVectorC"></span><span class="target" id="classLLU_1_1DataList_1a6439eef9e7c1afe295fcaa0711f89e75"></span>std::vector&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU8DataNodeE" title="LLU::DataNode">DataNode</a>&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU8DataListE" title="LLU::DataList::T">T</a>&gt;&gt; <code class="sig-name descname">toVector</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList8toVectorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return a vector of <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> nodes. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a std::vector of nodes in the form of DataNode&lt;T&gt; objects </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList6lengthEv">
<span id="_CPPv3NK3LLU8DataList6lengthEv"></span><span id="_CPPv2NK3LLU8DataList6lengthEv"></span><span id="LLU::DataList::lengthC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a6fd15ca12397f4ce4532e0a8edc91dad"></span>mint <code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList6lengthEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the length of the DataStore. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>total number of nodes in the DataStore </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList5frontEv">
<span id="_CPPv3NK3LLU8DataList5frontEv"></span><span id="_CPPv2NK3LLU8DataList5frontEv"></span><span id="LLU::DataList::frontC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a52ebe36f1172a8a6c78974829e2c7d42"></span>DataStoreNode <code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList5frontEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the first node of the DataStore. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>first node, if it doesn’t exist the behavior is undefined </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList4backEv">
<span id="_CPPv3NK3LLU8DataList4backEv"></span><span id="_CPPv2NK3LLU8DataList4backEv"></span><span id="LLU::DataList::backC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1ab384d40119d299a88e486359f981e875"></span>DataStoreNode <code class="sig-name descname">back</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList4backEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the last node of the DataStore. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>last node, if it doesn’t exist the behavior is undefined </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEvN8Argument11WrapperTypeI4TypeEE">
<span id="_CPPv3I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEN8Argument11WrapperTypeI4TypeEE"></span><span id="_CPPv2I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEN8Argument11WrapperTypeI4TypeEE"></span>template&lt;MArgumentType <code class="sig-name descname">Type</code>, EnableIfUnambiguousWrapperType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEvN8Argument11WrapperTypeI4TypeEE" title="LLU::DataList::push_back::Type">Type</a>&gt; = 0&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1aaee75bd06f7c1ee7e4c20490377d1b54"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>Argument::WrapperType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEvN8Argument11WrapperTypeI4TypeEE" title="LLU::DataList::push_back::Type">Type</a>&gt; <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEvN8Argument11WrapperTypeI4TypeEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new nameless node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span></code>: - type of the node data expressed via the MArgumentType enum </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - a value to be pushed as the new node, must be a wrapper over a primitive LibraryLink type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEvNSt11string_viewEN8Argument11WrapperTypeI4TypeEE">
<span id="_CPPv3I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backENSt11string_viewEN8Argument11WrapperTypeI4TypeEE"></span><span id="_CPPv2I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backENSt11string_viewEN8Argument11WrapperTypeI4TypeEE"></span>template&lt;MArgumentType <code class="sig-name descname">Type</code>, EnableIfUnambiguousWrapperType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEvNSt11string_viewEN8Argument11WrapperTypeI4TypeEE" title="LLU::DataList::push_back::Type">Type</a>&gt; = 0&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1ad40f40841e383bc5a0efb82980763b4d"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>std::string_view <em>name</em>, Argument::WrapperType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEvNSt11string_viewEN8Argument11WrapperTypeI4TypeEE" title="LLU::DataList::push_back::Type">Type</a>&gt; <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_13MArgumentType_30EnableIfUnambiguousWrapperTypeI4TypeEEN3LLU8DataList9push_backEvNSt11string_viewEN8Argument11WrapperTypeI4TypeEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new named node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span></code>: - type of the node data expressed via the MArgumentType enum </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: - name of the new node, names in a DataStore do not have to be unique </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - a value to be pushed as the new node, must be a wrapper over a primitive LibraryLink type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I_13MArgumentTypeEN3LLU8DataList9push_backEvN8Argument5CTypeI4TypeEE">
<span id="_CPPv3I_13MArgumentTypeEN3LLU8DataList9push_backEN8Argument5CTypeI4TypeEE"></span><span id="_CPPv2I_13MArgumentTypeEN3LLU8DataList9push_backEN8Argument5CTypeI4TypeEE"></span>template&lt;MArgumentType <code class="sig-name descname">Type</code>&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1a60cdced64960c12dce0971b14e4c4338"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>Argument::CType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentTypeEN3LLU8DataList9push_backEvN8Argument5CTypeI4TypeEE" title="LLU::DataList::push_back::Type">Type</a>&gt; <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_13MArgumentTypeEN3LLU8DataList9push_backEvN8Argument5CTypeI4TypeEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new nameless node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span></code>: - type of the node data expressed via the MArgumentType enum </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - a value to be pushed as the new node, must be of a primitive LibraryLink type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I_13MArgumentTypeEN3LLU8DataList9push_backEvNSt11string_viewEN8Argument5CTypeI4TypeEE">
<span id="_CPPv3I_13MArgumentTypeEN3LLU8DataList9push_backENSt11string_viewEN8Argument5CTypeI4TypeEE"></span><span id="_CPPv2I_13MArgumentTypeEN3LLU8DataList9push_backENSt11string_viewEN8Argument5CTypeI4TypeEE"></span>template&lt;MArgumentType <code class="sig-name descname">Type</code>&gt;<br /><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1acdd4fcc28e845b06295196f12552b3ff"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>std::string_view <em>name</em>, Argument::CType&lt;<a class="reference internal" href="#_CPPv4I_13MArgumentTypeEN3LLU8DataList9push_backEvNSt11string_viewEN8Argument5CTypeI4TypeEE" title="LLU::DataList::push_back::Type">Type</a>&gt; <em>nodeValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_13MArgumentTypeEN3LLU8DataList9push_backEvNSt11string_viewEN8Argument5CTypeI4TypeEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new named node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span></code>: - type of the node data expressed via the MArgumentType enum </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: - name of the new node, names in a DataStore do not have to be unique </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodeValue</span></code>: - a value to be pushed as the new node, must be of a primitive LibraryLink type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataList9push_backERKN8Argument5Typed3AnyE">
<span id="_CPPv3N3LLU8DataList9push_backERKN8Argument5Typed3AnyE"></span><span id="_CPPv2N3LLU8DataList9push_backERKN8Argument5Typed3AnyE"></span><span id="LLU::DataList::push_back__Argument::Typed::AnyCR"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1abc1b8dfda081167936403373f112c7f6"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span><em class="property">const</em> Argument::<a class="reference internal" href="#_CPPv4N3LLU8Argument5TypedE" title="LLU::Argument::Typed">Typed</a>::<a class="reference internal" href="#_CPPv4N3LLU8Argument5Typed3AnyE" title="LLU::Argument::Typed::Any">Any</a> &amp;<em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataList9push_backERKN8Argument5Typed3AnyE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new nameless node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">node</span></code>: - a value to be pushed as the new node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataList9push_backENSt11string_viewERKN8Argument5Typed3AnyE">
<span id="_CPPv3N3LLU8DataList9push_backENSt11string_viewERKN8Argument5Typed3AnyE"></span><span id="_CPPv2N3LLU8DataList9push_backENSt11string_viewERKN8Argument5Typed3AnyE"></span><span id="LLU::DataList::push_back__std::string_view.Argument::Typed::AnyCR"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4_1acdbe5f0b3173053936b042504f305072"></span>void <code class="sig-name descname">push_back</code><span class="sig-paren">(</span>std::string_view <em>name</em>, <em class="property">const</em> Argument::<a class="reference internal" href="#_CPPv4N3LLU8Argument5TypedE" title="LLU::Argument::Typed">Typed</a>::<a class="reference internal" href="#_CPPv4N3LLU8Argument5Typed3AnyE" title="LLU::Argument::Typed::Any">Any</a> &amp;<em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataList9push_backENSt11string_viewERKN8Argument5Typed3AnyE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Add new named node at the end of the underlying DataStore. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: - name of the new node, names in a DataStore do not have to be unique </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">node</span></code>: - a value to be pushed as the new node, </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList12getContainerEv">
<span id="_CPPv3NK3LLU8DataList12getContainerEv"></span><span id="_CPPv2NK3LLU8DataList12getContainerEv"></span><span id="LLU::DataList::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList9ContainerE" title="LLU::DataList::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList16abandonContainerEv">
<span id="_CPPv3NK3LLU8DataList16abandonContainerEv"></span><span id="_CPPv2NK3LLU8DataList16abandonContainerEv"></span><span id="LLU::DataList::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU8DataList9ContainerE" title="LLU::DataList::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList10shareCountEv">
<span id="_CPPv3NK3LLU8DataList10shareCountEv"></span><span id="_CPPv2NK3LLU8DataList10shareCountEv"></span><span id="LLU::DataList::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList4passER9MArgument">
<span id="_CPPv3NK3LLU8DataList4passER9MArgument"></span><span id="_CPPv2NK3LLU8DataList4passER9MArgument"></span><span id="LLU::DataList::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataList8getOwnerEv">
<span id="_CPPv3NK3LLU8DataList8getOwnerEv"></span><span id="_CPPv2NK3LLU8DataList8getOwnerEv"></span><span id="LLU::DataList::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU8DataList8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="llu-image-t">
<span id="image-label"></span><h3><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::Image&lt;T&gt;</span></code></a><a class="headerlink" href="#llu-image-t" title="Permalink to this headline"> 🔗</a></h3>
<p>Image is a strongly-typed wrapper derived from GenericImage, where the underlying data type is known at compile time and encoded in the template parameter.
The table below shows the correspondence between Image data types in LLU, plain LibraryLink and in the Wolfram Language:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 33%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>LLU (C++) type</p></th>
<th class="head"><p>LibraryLink type</p></th>
<th class="head"><p>Wolfram Language type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>std::int8_t</p></td>
<td><p>MImage_Type_Bit</p></td>
<td><p>“Bit”</p></td>
</tr>
<tr class="row-odd"><td><p>std::uint8_t</p></td>
<td><p>MImage_Type_Bit8</p></td>
<td><p>“Byte”</p></td>
</tr>
<tr class="row-even"><td><p>std::int16_t</p></td>
<td><p>MImage_Type_Bit16</p></td>
<td><p>“Bit16”</p></td>
</tr>
<tr class="row-odd"><td><p>float</p></td>
<td><p>MImage_Type_Real32</p></td>
<td><p>“Real32”</p></td>
</tr>
<tr class="row-even"><td><p>double</p></td>
<td><p>MImage_Type_Real</p></td>
<td><p>“Real64”</p></td>
</tr>
</tbody>
</table>
<p>Here is an example of the Image class in action:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* Take a constant &quot;Byte&quot; image and return a copy with negated pixel values */</span>
<span class="n">LIBRARY_LINK_FUNCTION</span><span class="p">(</span><span class="n">NegateImage</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">MArgumentManager</span> <span class="n">mngr</span> <span class="p">{</span><span class="n">libData</span><span class="p">,</span> <span class="n">Argc</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Res</span><span class="p">};</span>

   <span class="k">const</span> <span class="k">auto</span> <span class="n">image</span> <span class="o">=</span> <span class="n">mngr</span><span class="p">.</span><span class="n">getImage</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">LLU</span><span class="o">::</span><span class="n">Passing</span><span class="o">::</span><span class="n">Constant</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

   <span class="n">LLU</span><span class="o">::</span><span class="n">Image</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">outImage</span> <span class="p">{</span><span class="n">image</span><span class="p">.</span><span class="n">clone</span><span class="p">()};</span>
   <span class="k">constexpr</span> <span class="kt">uint8_t</span> <span class="n">negator</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">)();</span>
   <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">outImage</span><span class="p">),</span> <span class="p">[](</span><span class="n">T</span> <span class="n">inElem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">negator</span> <span class="o">-</span> <span class="n">inElem</span><span class="p">;</span> <span class="p">});</span>

   <span class="n">mngr</span><span class="p">.</span><span class="n">setImage</span><span class="p">(</span><span class="n">outImage</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">LLU</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">NoError</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>On the Wolfram Language side, we can load and use this function as follows:</p>
<div class="highlight-wolfram-language notranslate"><div class="highlight"><pre><span></span><span class="nv">`LLU`PacletFunctionSet</span><span class="p">[</span><span class="nv">NegateImage</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NegateImage&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{{</span><span class="nb">Image</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Constant&quot;</span><span class="p">}},</span><span class="w"> </span><span class="nb">Image</span><span class="p">]</span><span class="o">;</span><span class="w"></span>

<span class="nv">NegateImage</span><span class="p">[</span><span class="nb">Image</span><span class="p">[</span><span class="nb">RandomImage</span><span class="p">[</span><span class="nb">ColorSpace</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;RGB&quot;</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;Byte&quot;</span><span class="p">]]</span><span class="w"></span>

<span class="c">(* Out[] = [--Image--] *)</span><span class="w"></span>
</pre></div>
</div>
<p>This is only an example, Wolfram Language already has a built-in function for negating images: <a class="reference external" href="https://reference.wolfram.com/language/ref/ImageNegate">ImageNegate</a>.</p>
<p>In the example above we simply assumed that the Image we use will be of type “Byte”, so we could simply write <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">LLU</span><span class="pre">::</span><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image"><span class="pre">Image</span></a><span class="pre">&lt;</span><span class="pre">uint8_t</span><span class="pre">&gt;</span></code> in the C++ code.
In the next example let’s consider a function that takes two images from LibraryLink of arbitrary types and converts the second one to the data type of the
first one. In this case we cannot simply read arguments from MArgumentManager because we don’t know what template arguments should be passed to LLU::Image.
Instead, we call a function <a class="reference internal" href="functions.html#_CPPv4I_7Passing0DpEN3LLU16MArgumentManager14operateOnImageEv9size_typeDpRR4Args" title="LLU::MArgumentManager::operateOnImage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">LLU::MArgumentManager::operateOnImage()</span></code></a> which lets us evaluate a function template on an input image without knowing its data type.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">LIBRARY_LINK_FUNCTION</span><span class="p">(</span><span class="n">UnifyImageTypes</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">MArgumentManager</span> <span class="n">mngr</span> <span class="p">{</span><span class="n">libData</span><span class="p">,</span> <span class="n">Argc</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Res</span><span class="p">};</span>

   <span class="c1">// Take an image passed to the library function as the first argument, deduce its data type, create a corresponding LLU::Image wrapper and evaluate</span>
   <span class="c1">// given generic lambda function on this image</span>
   <span class="n">mngr</span><span class="p">.</span><span class="n">operateOnImage</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">mngr</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">firstImage</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// T is the data type of the first image</span>
      <span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">firstImage</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">;</span>

      <span class="c1">// Similarly, read the second image and create a properly typed LLU::Image wrapper</span>
      <span class="n">mngr</span><span class="p">.</span><span class="n">operateOnImage</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">mngr</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">secondImage</span><span class="p">)</span> <span class="p">{</span>

         <span class="c1">// Convert the second image to the data type of the first one and return as the library function result</span>
         <span class="n">LLU</span><span class="o">::</span><span class="n">Image</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">out</span> <span class="p">{</span><span class="n">secondImage</span><span class="p">.</span><span class="k">template</span> <span class="n">convert</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()};</span>
         <span class="n">mngr</span><span class="p">.</span><span class="n">setImage</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
      <span class="p">});</span>
   <span class="p">});</span>
   <span class="k">return</span> <span class="n">LLU</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">NoError</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<dl class="cpp class">
<dt id="_CPPv4I0EN3LLU5ImageE">
<span id="_CPPv3I0EN3LLU5ImageE"></span><span id="_CPPv2I0EN3LLU5ImageE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classLLU_1_1Image"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Image</code> : <em class="property">public</em> LLU::TypedImage&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a>&gt;, <em class="property">public</em> LLU::<a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType5ImageEEE" title="LLU::MContainer&lt;MArgumentType::Image&gt;">MContainer</a>&lt;MArgumentType::Image&gt;<a class="headerlink" href="#_CPPv4I0EN3LLU5ImageE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>This is a class template, where template parameter T is the type of data elements. <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> is derived from MArray. </p>
<p>Image&lt;&gt; classes automate creation and deletion of MImages. They are strongly typed (no void* to underlying memory) and almost all functions from &lt;algorithms&gt; can be used on <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a>.</p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: - type of underlying data </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU5Image10value_typeE">
<span id="_CPPv3N3LLU5Image10value_typeE"></span><span id="_CPPv2N3LLU5Image10value_typeE"></span><span class="target" id="classLLU_1_1IterableContainer_1aae6a9d571c13ce824507d7787d316503"></span><em class="property">using </em><code class="sig-name descname">value_type</code> = <a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a><a class="headerlink" href="#_CPPv4N3LLU5Image10value_typeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Type of elements stored. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU5Image8iteratorE">
<span id="_CPPv3N3LLU5Image8iteratorE"></span><span id="_CPPv2N3LLU5Image8iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1ac8b597819b579738c0a276da4b8d33fc"></span><em class="property">using </em><code class="sig-name descname">iterator</code> = <a class="reference internal" href="#_CPPv4N3LLU5Image10value_typeE" title="LLU::Image::value_type">value_type</a>*<a class="headerlink" href="#_CPPv4N3LLU5Image8iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU5Image14const_iteratorE">
<span id="_CPPv3N3LLU5Image14const_iteratorE"></span><span id="_CPPv2N3LLU5Image14const_iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1a9a8695babde8c0d183f68cd3c95101f8"></span><em class="property">using </em><code class="sig-name descname">const_iterator</code> = <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU5Image10value_typeE" title="LLU::Image::value_type">value_type</a>*<a class="headerlink" href="#_CPPv4N3LLU5Image14const_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constant iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU5Image16reverse_iteratorE">
<span id="_CPPv3N3LLU5Image16reverse_iteratorE"></span><span id="_CPPv2N3LLU5Image16reverse_iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1a41529a4e72b6b181a2b39939b58bd15d"></span><em class="property">using </em><code class="sig-name descname">reverse_iterator</code> = std::reverse_iterator&lt;<a class="reference internal" href="#_CPPv4N3LLU5Image8iteratorE" title="LLU::Image::iterator">iterator</a>&gt;<a class="headerlink" href="#_CPPv4N3LLU5Image16reverse_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Reverse iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU5Image22const_reverse_iteratorE">
<span id="_CPPv3N3LLU5Image22const_reverse_iteratorE"></span><span id="_CPPv2N3LLU5Image22const_reverse_iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1a6f6c37582422b85f59ed4323eca98584"></span><em class="property">using </em><code class="sig-name descname">const_reverse_iterator</code> = std::reverse_iterator&lt;<a class="reference internal" href="#_CPPv4N3LLU5Image14const_iteratorE" title="LLU::Image::const_iterator">const_iterator</a>&gt;<a class="headerlink" href="#_CPPv4N3LLU5Image22const_reverse_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constant reverse iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU5Image9referenceE">
<span id="_CPPv3N3LLU5Image9referenceE"></span><span id="_CPPv2N3LLU5Image9referenceE"></span><span class="target" id="classLLU_1_1IterableContainer_1a434c506653af6c6a1da3af51ba478625"></span><em class="property">using </em><code class="sig-name descname">reference</code> = <a class="reference internal" href="#_CPPv4N3LLU5Image10value_typeE" title="LLU::Image::value_type">value_type</a>&amp;<a class="headerlink" href="#_CPPv4N3LLU5Image9referenceE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Reference type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU5Image15const_referenceE">
<span id="_CPPv3N3LLU5Image15const_referenceE"></span><span id="_CPPv2N3LLU5Image15const_referenceE"></span><span class="target" id="classLLU_1_1IterableContainer_1aa638ab9c633ff30d210c1c833a8b3c8f"></span><em class="property">using </em><code class="sig-name descname">const_reference</code> = <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU5Image10value_typeE" title="LLU::Image::value_type">value_type</a>&amp;<a class="headerlink" href="#_CPPv4N3LLU5Image15const_referenceE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constant reference type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU5Image9ContainerE">
<span id="_CPPv3N3LLU5Image9ContainerE"></span><span id="_CPPv2N3LLU5Image9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU5Image9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image5ImageE4mint4mint4mint12colorspace_tb">
<span id="_CPPv3N3LLU5Image5ImageE4mint4mint4mint12colorspace_tb"></span><span id="_CPPv2N3LLU5Image5ImageE4mint4mint4mint12colorspace_tb"></span><span id="LLU::Image::Image__mint.mint.mint.colorspace_t.b"></span><span class="target" id="classLLU_1_1Image_1a2a8b41f653510929475227d8a41041c6"></span><code class="sig-name descname">Image</code><span class="sig-paren">(</span>mint <em>w</em>, mint <em>h</em>, mint <em>channels</em>, colorspace_t <em>cs</em>, bool <em>interleavingQ</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image5ImageE4mint4mint4mint12colorspace_tb" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs new 2D <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a>. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">w</span></code>: - <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> width (number of columns) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">h</span></code>: - <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> height (number of rows) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">channels</span></code>: - number of channels </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">cs</span></code>: - color space </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">interleavingQ</span></code>: - whether <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> data should be interleaved </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image5ImageE4mint4mint4mint4mint12colorspace_tb">
<span id="_CPPv3N3LLU5Image5ImageE4mint4mint4mint4mint12colorspace_tb"></span><span id="_CPPv2N3LLU5Image5ImageE4mint4mint4mint4mint12colorspace_tb"></span><span id="LLU::Image::Image__mint.mint.mint.mint.colorspace_t.b"></span><span class="target" id="classLLU_1_1Image_1ada25511815b44fc119a1e2a74e534e43"></span><code class="sig-name descname">Image</code><span class="sig-paren">(</span>mint <em>nFrames</em>, mint <em>w</em>, mint <em>h</em>, mint <em>channels</em>, colorspace_t <em>cs</em>, bool <em>interleavingQ</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image5ImageE4mint4mint4mint4mint12colorspace_tb" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs new 3D <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a>. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">nFrames</span></code>: - number of 2D frames/slices </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">w</span></code>: - <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> width (number of columns) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">h</span></code>: - <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> height (number of rows) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">channels</span></code>: - number of channels </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">cs</span></code>: - color space </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">interleavingQ</span></code>: - whether <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> data should be interleaved </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::ImageNewError</span></code>: - if internal MImage creation failed </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image5ImageE12GenericImage">
<span id="_CPPv3N3LLU5Image5ImageE12GenericImage"></span><span id="_CPPv2N3LLU5Image5ImageE12GenericImage"></span><span id="LLU::Image::Image__GenericImage"></span><span class="target" id="classLLU_1_1Image_1a06ee24b16e45605125598c7e6cc4239f"></span><code class="sig-name descname">Image</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N3LLU12GenericImageE" title="LLU::GenericImage">GenericImage</a> <em>im</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image5ImageE12GenericImage" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create new <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> from a GenericImage. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">im</span></code>: - generic image to be wrapped into <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> class </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::ImageTypeError</span></code>: - if the <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> template type <strong>T</strong> does not match the actual data type of the generic image </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image5ImageE6MImage9Ownership">
<span id="_CPPv3N3LLU5Image5ImageE6MImage9Ownership"></span><span id="_CPPv2N3LLU5Image5ImageE6MImage9Ownership"></span><span id="LLU::Image::Image__MImage.Ownership"></span><span class="target" id="classLLU_1_1Image_1ae84b2eb54fe2e3eb9a9207083d114e12"></span><code class="sig-name descname">Image</code><span class="sig-paren">(</span>MImage <em>mi</em>, <a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image5ImageE6MImage9Ownership" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> based on MImage. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">mi</span></code>: - LibraryLink structure to be wrapped </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">owner</span></code>: - who manages the memory the raw MImage </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::ImageTypeError</span></code>: - if template parameter <strong>T</strong> does not match MImage data type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::ImageSizeError</span></code>: - if constructor failed to calculate image dimensions properly </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image5ImageEv">
<span id="_CPPv3N3LLU5Image5ImageEv"></span><span id="_CPPv2N3LLU5Image5ImageEv"></span><span id="LLU::Image::Image"></span><span class="target" id="classLLU_1_1Image_1a636f5bae44359b97700044a8615611cd"></span><code class="sig-name descname">Image</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N3LLU5Image5ImageEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default constructor - creates an empty wrapper. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image5cloneEv">
<span id="_CPPv3NK3LLU5Image5cloneEv"></span><span id="_CPPv2NK3LLU5Image5cloneEv"></span><span id="LLU::Image::cloneC"></span><span class="target" id="classLLU_1_1Image_1af57057993453afd91c68178953db8be1"></span><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image">Image</a> <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a>, performing a deep copy of the underlying MImage. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned MImage always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0ENK3LLU5Image7convertE5ImageI1UEb">
<span id="_CPPv3I0ENK3LLU5Image7convertEb"></span><span id="_CPPv2I0ENK3LLU5Image7convertEb"></span>template&lt;typename <code class="sig-name descname">U</code>&gt;<br /><span class="target" id="classLLU_1_1Image_1a4370be9c49d3cbd60ee1e20a5d42e125"></span><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image">Image</a>&lt;<a class="reference internal" href="#_CPPv4I0ENK3LLU5Image7convertE5ImageI1UEb" title="LLU::Image::convert::U">U</a>&gt; <code class="sig-name descname">convert</code><span class="sig-paren">(</span>bool <em>interleaved</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4I0ENK3LLU5Image7convertE5ImageI1UEb" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Copy this image with type conversion and explicitly specified interleaving. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">U</span></code>: - any type that <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> supports </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">interleaved</span></code>: - whether the newly created <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> should be interleaved </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>newly created <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> of type U and specified interleaving </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0ENK3LLU5Image7convertE5ImageI1UEv">
<span id="_CPPv3I0ENK3LLU5Image7convertEv"></span><span id="_CPPv2I0ENK3LLU5Image7convertEv"></span>template&lt;typename <code class="sig-name descname">U</code>&gt;<br /><span class="target" id="classLLU_1_1Image_1a8d8b02e21eeaf82ac727a3508eecf33f"></span><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image">Image</a>&lt;<a class="reference internal" href="#_CPPv4I0ENK3LLU5Image7convertE5ImageI1UEv" title="LLU::Image::convert::U">U</a>&gt; <code class="sig-name descname">convert</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4I0ENK3LLU5Image7convertE5ImageI1UEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Copy this image with type conversion and other properties (dimensions, interleaving, color space, etc.) untouched. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">U</span></code>: - any type that <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> supports </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>newly created <a class="reference internal" href="#classLLU_1_1Image"><span class="std std-ref">Image</span></a> of type U </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image3getE4mint4mint4mint">
<span id="_CPPv3NK3LLU5Image3getE4mint4mint4mint"></span><span id="_CPPv2NK3LLU5Image3getE4mint4mint4mint"></span><span id="LLU::Image::get__mint.mint.mintC"></span><span class="target" id="classLLU_1_1TypedImage_1ab74cc613a6c92a697fdfda07e747edf9"></span><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> <code class="sig-name descname">get</code><span class="sig-paren">(</span>mint <em>row</em>, mint <em>col</em>, mint <em>channel</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image3getE4mint4mint4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get channel value at specified position in 2D image. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">row</span></code>: - pixel row (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">col</span></code>: - pixel column (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">channel</span></code>: - desired channel (in Mathematica-style indexing - starting from 1) </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::ImageIndexError</span></code>: - if the specified coordinates are out-of-bound </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image3getE4mint4mint4mint4mint">
<span id="_CPPv3NK3LLU5Image3getE4mint4mint4mint4mint"></span><span id="_CPPv2NK3LLU5Image3getE4mint4mint4mint4mint"></span><span id="LLU::Image::get__mint.mint.mint.mintC"></span><span class="target" id="classLLU_1_1TypedImage_1a7d5054c5e2c8d8516e8beca7990d90eb"></span><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> <code class="sig-name descname">get</code><span class="sig-paren">(</span>mint <em>slice</em>, mint <em>row</em>, mint <em>col</em>, mint <em>channel</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image3getE4mint4mint4mint4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get channel value at specified position in 3D image. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">slice</span></code>: - slice index (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">row</span></code>: - pixel row (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">col</span></code>: - pixel column (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">channel</span></code>: - desired channel (in Mathematica-style indexing - starting from 1) </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::ImageIndexError</span></code>: - if the specified coordinates are out-of-bound </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image3setE4mint4mint4mint1T">
<span id="_CPPv3N3LLU5Image3setE4mint4mint4mint1T"></span><span id="_CPPv2N3LLU5Image3setE4mint4mint4mint1T"></span><span id="LLU::Image::set__mint.mint.mint.T"></span><span class="target" id="classLLU_1_1TypedImage_1af41f5c7a1f2f1a4a2941602d443ac0bc"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span>mint <em>row</em>, mint <em>col</em>, mint <em>channel</em>, <a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image3setE4mint4mint4mint1T" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Set channel value at specified position in 2D image. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">row</span></code>: - pixel row (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">col</span></code>: - pixel column (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">channel</span></code>: - desired channel (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">newValue</span></code>: - new channel value </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::ImageIndexError</span></code>: - if the specified coordinates are out-of-bound </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image3setE4mint4mint4mint4mint1T">
<span id="_CPPv3N3LLU5Image3setE4mint4mint4mint4mint1T"></span><span id="_CPPv2N3LLU5Image3setE4mint4mint4mint4mint1T"></span><span id="LLU::Image::set__mint.mint.mint.mint.T"></span><span class="target" id="classLLU_1_1TypedImage_1aa0c7311cb139510dd0ce6939e8b5dddf"></span>void <code class="sig-name descname">set</code><span class="sig-paren">(</span>mint <em>slice</em>, mint <em>row</em>, mint <em>col</em>, mint <em>channel</em>, <a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image3setE4mint4mint4mint4mint1T" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Set channel value at specified position in 3D image. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">slice</span></code>: - slice index (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">row</span></code>: - pixel row (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">col</span></code>: - pixel column (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">channel</span></code>: - desired channel (in Mathematica-style indexing - starting from 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">newValue</span></code>: - new channel value </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::ImageIndexError</span></code>: - if the specified coordinates are out-of-bound </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4rankEv">
<span id="_CPPv3NK3LLU5Image4rankEv"></span><span id="_CPPv2NK3LLU5Image4rankEv"></span><span id="LLU::Image::rankC"></span><span class="target" id="classLLU_1_1MArray_1a6a1f85549f320f4ccce4b8957495851a"></span>mint <code class="sig-name descname">rank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4rankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get container rank. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image5emptyEv">
<span id="_CPPv3NK3LLU5Image5emptyEv"></span><span id="_CPPv2NK3LLU5Image5emptyEv"></span><span id="LLU::Image::emptyC"></span><span class="target" id="classLLU_1_1MArray_1ad0660a7856ffd2ebb931a75a09b7dca7"></span>bool <code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image5emptyEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check whether container is empty. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image9dimensionE4mint">
<span id="_CPPv3NK3LLU5Image9dimensionE4mint"></span><span id="_CPPv2NK3LLU5Image9dimensionE4mint"></span><span id="LLU::Image::dimension__mintC"></span><span class="target" id="classLLU_1_1MArray_1a44e07e472aa8c85ff60a7afcb005da71"></span>mint <code class="sig-name descname">dimension</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image9dimensionE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get dimension value at position <code class="docutils literal notranslate"><span class="pre">index</span></code>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image10dimensionsEv">
<span id="_CPPv3NK3LLU5Image10dimensionsEv"></span><span id="_CPPv2NK3LLU5Image10dimensionsEv"></span><span id="LLU::Image::dimensionsC"></span><span class="target" id="classLLU_1_1MArray_1aee9a5b13a2234e858a788cf917843814"></span><em class="property">const</em> MArrayDimensions &amp;<code class="sig-name descname">dimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image10dimensionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a const reference to dimensions object. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5ImageixERKNSt6vectorI4mintEE">
<span id="_CPPv3N3LLU5ImageixERKNSt6vectorI4mintEE"></span><span id="_CPPv2N3LLU5ImageixERKNSt6vectorI4mintEE"></span><span id="LLU::Image::subscript-operator__std::vector:mint:CR"></span><span class="target" id="classLLU_1_1MArray_1ad649b2993c695ce2b102f4138c7758f8"></span><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> &amp;<code class="sig-name descname">operator[]</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5ImageixERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5ImageixERKNSt6vectorI4mintEE">
<span id="_CPPv3NK3LLU5ImageixERKNSt6vectorI4mintEE"></span><span id="_CPPv2NK3LLU5ImageixERKNSt6vectorI4mintEE"></span><span id="LLU::Image::subscript-operator__std::vector:mint:CRC"></span><span class="target" id="classLLU_1_1MArray_1a22590ae040ce13a69fc6dcf1a7064aab"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> &amp;<code class="sig-name descname">operator[]</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5ImageixERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5ImageixE4mint">
<span id="_CPPv3N3LLU5ImageixE4mint"></span><span id="_CPPv2N3LLU5ImageixE4mint"></span><span id="LLU::Image::subscript-operator__mint"></span><span class="target" id="classLLU_1_1IterableContainer_1a19a4221532b5d35e22b6573d46b87f80"></span><a class="reference internal" href="#_CPPv4N3LLU5Image9referenceE" title="LLU::Image::reference">reference</a> <code class="sig-name descname">operator[]</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5ImageixE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5ImageixE4mint">
<span id="_CPPv3NK3LLU5ImageixE4mint"></span><span id="_CPPv2NK3LLU5ImageixE4mint"></span><span id="LLU::Image::subscript-operator__mintC"></span><span class="target" id="classLLU_1_1IterableContainer_1a548d4460ce2474312c61ea7ad0b088f9"></span><a class="reference internal" href="#_CPPv4N3LLU5Image15const_referenceE" title="LLU::Image::const_reference">const_reference</a> <code class="sig-name descname">operator[]</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5ImageixE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image2atE4mint">
<span id="_CPPv3N3LLU5Image2atE4mint"></span><span id="_CPPv2N3LLU5Image2atE4mint"></span><span id="LLU::Image::at__mint"></span><span class="target" id="classLLU_1_1MArray_1a709e1c06e4891e210bca65c67cdbaad2"></span><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image2atE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position with bound checking. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">index</span></code> is out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image2atE4mint">
<span id="_CPPv3NK3LLU5Image2atE4mint"></span><span id="_CPPv2NK3LLU5Image2atE4mint"></span><span id="LLU::Image::at__mintC"></span><span class="target" id="classLLU_1_1MArray_1a4eba03b34a730d7a372ebd4081409509"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image2atE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position with bound checking. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">index</span></code> is out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image2atERKNSt6vectorI4mintEE">
<span id="_CPPv3N3LLU5Image2atERKNSt6vectorI4mintEE"></span><span id="_CPPv2N3LLU5Image2atERKNSt6vectorI4mintEE"></span><span id="LLU::Image::at__std::vector:mint:CR"></span><span class="target" id="classLLU_1_1MArray_1a97b1d5b38f646fb55c0855699f648012"></span><a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image2atERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">indices</span></code> are out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image2atERKNSt6vectorI4mintEE">
<span id="_CPPv3NK3LLU5Image2atERKNSt6vectorI4mintEE"></span><span id="_CPPv2NK3LLU5Image2atERKNSt6vectorI4mintEE"></span><span id="LLU::Image::at__std::vector:mint:CRC"></span><span class="target" id="classLLU_1_1MArray_1a336ad439eabceff0ec49bcd01ff5e251"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU5ImageE" title="LLU::Image::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image2atERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">indices</span></code> are out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image4dataEv">
<span id="_CPPv3N3LLU5Image4dataEv"></span><span id="_CPPv2N3LLU5Image4dataEv"></span><span id="LLU::Image::data"></span><span class="target" id="classLLU_1_1IterableContainer_1a1f9294306bb0f09963859cbf5a395e4b"></span><a class="reference internal" href="#_CPPv4N3LLU5Image10value_typeE" title="LLU::Image::value_type">value_type</a> *<code class="sig-name descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU5Image4dataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get raw pointer to underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4dataEv">
<span id="_CPPv3NK3LLU5Image4dataEv"></span><span id="_CPPv2NK3LLU5Image4dataEv"></span><span id="LLU::Image::dataC"></span><span class="target" id="classLLU_1_1IterableContainer_1ad074c86ef619bc6354b37018e7b55a18"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU5Image10value_typeE" title="LLU::Image::value_type">value_type</a> *<code class="sig-name descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4dataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get raw pointer to const underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4sizeEv">
<span id="_CPPv3NK3LLU5Image4sizeEv"></span><span id="_CPPv2NK3LLU5Image4sizeEv"></span><span id="LLU::Image::sizeC"></span><span class="target" id="classLLU_1_1IterableContainer_1ab3046c61f8bb0e1db83ec4907fbc5087"></span>mint <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4sizeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get total number of elements in the container. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image5beginEv">
<span id="_CPPv3N3LLU5Image5beginEv"></span><span id="_CPPv2N3LLU5Image5beginEv"></span><span id="LLU::Image::begin"></span><span class="target" id="classLLU_1_1IterableContainer_1adbbf7628ba97cdb30fe78000d2b5fc20"></span><a class="reference internal" href="#_CPPv4N3LLU5Image8iteratorE" title="LLU::Image::iterator">iterator</a> <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU5Image5beginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image5beginEv">
<span id="_CPPv3NK3LLU5Image5beginEv"></span><span id="_CPPv2NK3LLU5Image5beginEv"></span><span id="LLU::Image::beginC"></span><span class="target" id="classLLU_1_1IterableContainer_1ac107dad385fa41d1853766bc6ef249ec"></span><a class="reference internal" href="#_CPPv4N3LLU5Image14const_iteratorE" title="LLU::Image::const_iterator">const_iterator</a> <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image5beginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image6cbeginEv">
<span id="_CPPv3NK3LLU5Image6cbeginEv"></span><span id="_CPPv2NK3LLU5Image6cbeginEv"></span><span id="LLU::Image::cbeginC"></span><span class="target" id="classLLU_1_1IterableContainer_1a58ec84224bf0e8ca8927e4553cb8afb8"></span><a class="reference internal" href="#_CPPv4N3LLU5Image14const_iteratorE" title="LLU::Image::const_iterator">const_iterator</a> <code class="sig-name descname">cbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image6cbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image3endEv">
<span id="_CPPv3N3LLU5Image3endEv"></span><span id="_CPPv2N3LLU5Image3endEv"></span><span id="LLU::Image::end"></span><span class="target" id="classLLU_1_1IterableContainer_1a9bd4ff608c8087acd4abae3df8c177e8"></span><a class="reference internal" href="#_CPPv4N3LLU5Image8iteratorE" title="LLU::Image::iterator">iterator</a> <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU5Image3endEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image3endEv">
<span id="_CPPv3NK3LLU5Image3endEv"></span><span id="_CPPv2NK3LLU5Image3endEv"></span><span id="LLU::Image::endC"></span><span class="target" id="classLLU_1_1IterableContainer_1af0164d7e75cc5b8c3ae7b7625e75ccbd"></span><a class="reference internal" href="#_CPPv4N3LLU5Image14const_iteratorE" title="LLU::Image::const_iterator">const_iterator</a> <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image3endEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4cendEv">
<span id="_CPPv3NK3LLU5Image4cendEv"></span><span id="_CPPv2NK3LLU5Image4cendEv"></span><span id="LLU::Image::cendC"></span><span class="target" id="classLLU_1_1IterableContainer_1a5734bc636b9edca9dda9e7ac69c50d37"></span><a class="reference internal" href="#_CPPv4N3LLU5Image14const_iteratorE" title="LLU::Image::const_iterator">const_iterator</a> <code class="sig-name descname">cend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4cendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image6rbeginEv">
<span id="_CPPv3N3LLU5Image6rbeginEv"></span><span id="_CPPv2N3LLU5Image6rbeginEv"></span><span id="LLU::Image::rbegin"></span><span class="target" id="classLLU_1_1IterableContainer_1a5d59ccc0e700a96c51045f0d5ee69883"></span><a class="reference internal" href="#_CPPv4N3LLU5Image16reverse_iteratorE" title="LLU::Image::reverse_iterator">reverse_iterator</a> <code class="sig-name descname">rbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU5Image6rbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image6rbeginEv">
<span id="_CPPv3NK3LLU5Image6rbeginEv"></span><span id="_CPPv2NK3LLU5Image6rbeginEv"></span><span id="LLU::Image::rbeginC"></span><span class="target" id="classLLU_1_1IterableContainer_1a177fe159a37bbaf8eb8546b26fb0f9e3"></span><a class="reference internal" href="#_CPPv4N3LLU5Image22const_reverse_iteratorE" title="LLU::Image::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">rbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image6rbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image7crbeginEv">
<span id="_CPPv3NK3LLU5Image7crbeginEv"></span><span id="_CPPv2NK3LLU5Image7crbeginEv"></span><span id="LLU::Image::crbeginC"></span><span class="target" id="classLLU_1_1IterableContainer_1a03798d561430d17054f801bcf4ca4510"></span><a class="reference internal" href="#_CPPv4N3LLU5Image22const_reverse_iteratorE" title="LLU::Image::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">crbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image7crbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image4rendEv">
<span id="_CPPv3N3LLU5Image4rendEv"></span><span id="_CPPv2N3LLU5Image4rendEv"></span><span id="LLU::Image::rend"></span><span class="target" id="classLLU_1_1IterableContainer_1adc895d42aa8cb4e1fa3145eb9f83a5fb"></span><a class="reference internal" href="#_CPPv4N3LLU5Image16reverse_iteratorE" title="LLU::Image::reverse_iterator">reverse_iterator</a> <code class="sig-name descname">rend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU5Image4rendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4rendEv">
<span id="_CPPv3NK3LLU5Image4rendEv"></span><span id="_CPPv2NK3LLU5Image4rendEv"></span><span id="LLU::Image::rendC"></span><span class="target" id="classLLU_1_1IterableContainer_1af053c33d89fc05f1c9368df1b6a5d00d"></span><a class="reference internal" href="#_CPPv4N3LLU5Image22const_reverse_iteratorE" title="LLU::Image::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">rend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4rendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image5crendEv">
<span id="_CPPv3NK3LLU5Image5crendEv"></span><span id="_CPPv2NK3LLU5Image5crendEv"></span><span id="LLU::Image::crendC"></span><span class="target" id="classLLU_1_1IterableContainer_1ac6a8810748705c2359a379dab9f3c396"></span><a class="reference internal" href="#_CPPv4N3LLU5Image22const_reverse_iteratorE" title="LLU::Image::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">crend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image5crendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image5frontEv">
<span id="_CPPv3N3LLU5Image5frontEv"></span><span id="_CPPv2N3LLU5Image5frontEv"></span><span id="LLU::Image::front"></span><span class="target" id="classLLU_1_1IterableContainer_1af22c6027070c7fd150bb86a53d8f50de"></span><a class="reference internal" href="#_CPPv4N3LLU5Image9referenceE" title="LLU::Image::reference">reference</a> <code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image5frontEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get reference to the first element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image5frontEv">
<span id="_CPPv3NK3LLU5Image5frontEv"></span><span id="_CPPv2NK3LLU5Image5frontEv"></span><span id="LLU::Image::frontC"></span><span class="target" id="classLLU_1_1IterableContainer_1ad11d7f07a4e7ff56818d4b038646525d"></span><a class="reference internal" href="#_CPPv4N3LLU5Image15const_referenceE" title="LLU::Image::const_reference">const_reference</a> <code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image5frontEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant reference to the first element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU5Image4backEv">
<span id="_CPPv3N3LLU5Image4backEv"></span><span id="_CPPv2N3LLU5Image4backEv"></span><span id="LLU::Image::back"></span><span class="target" id="classLLU_1_1IterableContainer_1abcde345515a1529d00d7f35bdd3c428e"></span><a class="reference internal" href="#_CPPv4N3LLU5Image9referenceE" title="LLU::Image::reference">reference</a> <code class="sig-name descname">back</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU5Image4backEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get reference to the last element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4backEv">
<span id="_CPPv3NK3LLU5Image4backEv"></span><span id="_CPPv2NK3LLU5Image4backEv"></span><span id="LLU::Image::backC"></span><span class="target" id="classLLU_1_1IterableContainer_1a74006685a7c15be6030f7217d761280a"></span><a class="reference internal" href="#_CPPv4N3LLU5Image15const_referenceE" title="LLU::Image::const_reference">const_reference</a> <code class="sig-name descname">back</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4backEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant reference to the last element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image8asVectorEv">
<span id="_CPPv3NK3LLU5Image8asVectorEv"></span><span id="_CPPv2NK3LLU5Image8asVectorEv"></span><span id="LLU::Image::asVectorC"></span><span class="target" id="classLLU_1_1IterableContainer_1af66aee992031feec7f2c41a50b71a8b6"></span>std::vector&lt;<a class="reference internal" href="#_CPPv4N3LLU5Image10value_typeE" title="LLU::Image::value_type">value_type</a>&gt; <code class="sig-name descname">asVector</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image8asVectorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Copy contents of the data to a std::vector of matching type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>std::vector with the copy of the data </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image7convertE11imagedata_t5mbool">
<span id="_CPPv3NK3LLU5Image7convertE11imagedata_t5mbool"></span><span id="_CPPv2NK3LLU5Image7convertE11imagedata_t5mbool"></span><span id="LLU::Image::convert__imagedata_t.mboolC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a6a64a4d9b550eafe4885af3444366101"></span><a class="reference internal" href="#_CPPv4N3LLU12GenericImageE" title="LLU::GenericImage">GenericImage</a> <code class="sig-name descname">convert</code><span class="sig-paren">(</span>imagedata_t <em>t</em>, mbool <em>interleavingQ</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image7convertE11imagedata_t5mbool" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Convert this object to a new GenericImage of given datatype, optionally changing interleaving. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: - destination data type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interleavingQ</span></code>: - whether the converted GenericImage should be interleaved or not </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>converted GenericImage owned by the Library </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_convertType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_convertType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image7convertE11imagedata_t">
<span id="_CPPv3NK3LLU5Image7convertE11imagedata_t"></span><span id="_CPPv2NK3LLU5Image7convertE11imagedata_t"></span><span id="LLU::Image::convert__imagedata_tC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a5f2872c0b22afe7218cefa561b392464"></span><a class="reference internal" href="#_CPPv4N3LLU12GenericImageE" title="LLU::GenericImage">GenericImage</a> <code class="sig-name descname">convert</code><span class="sig-paren">(</span>imagedata_t <em>t</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image7convertE11imagedata_t" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Convert this object to a new GenericImage of given datatype. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: - destination data type </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>converted GenericImage owned by the Library </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_convertType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_convertType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image10colorspaceEv">
<span id="_CPPv3NK3LLU5Image10colorspaceEv"></span><span id="_CPPv2NK3LLU5Image10colorspaceEv"></span><span id="LLU::Image::colorspaceC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1afd9d7e2706d763f05e41aafa55b2bd5a"></span>colorspace_t <code class="sig-name descname">colorspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image10colorspaceEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get colorspace which describes how colors are represented as numbers. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getColorSpace.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getColorSpace.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4rowsEv">
<span id="_CPPv3NK3LLU5Image4rowsEv"></span><span id="_CPPv2NK3LLU5Image4rowsEv"></span><span id="LLU::Image::rowsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1ada89917233c80bb6c976462f24ba502f"></span>mint <code class="sig-name descname">rows</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4rowsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get number of rows. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRowCount.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRowCount.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image7columnsEv">
<span id="_CPPv3NK3LLU5Image7columnsEv"></span><span id="_CPPv2NK3LLU5Image7columnsEv"></span><span id="LLU::Image::columnsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1aa0dc9cc9b2ef3ed9baf2e6eaabbf8190"></span>mint <code class="sig-name descname">columns</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image7columnsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get number of columns. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getColumnCount.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getColumnCount.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image6slicesEv">
<span id="_CPPv3NK3LLU5Image6slicesEv"></span><span id="_CPPv2NK3LLU5Image6slicesEv"></span><span id="LLU::Image::slicesC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a4353353b3b1f82ed3be6b9d638dc5449"></span>mint <code class="sig-name descname">slices</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image6slicesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get number of slices. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getSliceCount.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getSliceCount.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image8channelsEv">
<span id="_CPPv3NK3LLU5Image8channelsEv"></span><span id="_CPPv2NK3LLU5Image8channelsEv"></span><span id="LLU::Image::channelsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1aa96760718aae476b9d137ae930d4fe20"></span>mint <code class="sig-name descname">channels</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image8channelsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get number of channels. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getChannels.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getChannels.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image13alphaChannelQEv">
<span id="_CPPv3NK3LLU5Image13alphaChannelQEv"></span><span id="_CPPv2NK3LLU5Image13alphaChannelQEv"></span><span id="LLU::Image::alphaChannelQC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a9122d4d21578404a9799a0537cb2ad21"></span>bool <code class="sig-name descname">alphaChannelQ</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image13alphaChannelQEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check if there is an alpha channel in the image. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_alphaChannelQ.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_alphaChannelQ.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image12interleavedQEv">
<span id="_CPPv3NK3LLU5Image12interleavedQEv"></span><span id="_CPPv2NK3LLU5Image12interleavedQEv"></span><span id="LLU::Image::interleavedQC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1af3639070e4ee43f6b35ca8159f2d4df5"></span>bool <code class="sig-name descname">interleavedQ</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image12interleavedQEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check if the image is interleaved. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_interleavedQ.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_interleavedQ.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4is3DEv">
<span id="_CPPv3NK3LLU5Image4is3DEv"></span><span id="_CPPv2NK3LLU5Image4is3DEv"></span><span id="LLU::Image::is3DC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a3d26e0b815c263c3d2f5ae6cd57f7089"></span>bool <code class="sig-name descname">is3D</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4is3DEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check if the image is 3D. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image7getRankEv">
<span id="_CPPv3NK3LLU5Image7getRankEv"></span><span id="_CPPv2NK3LLU5Image7getRankEv"></span><span id="LLU::Image::getRankC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1acb78a7ae597ce55ca0ae1217f2e7cd82"></span>mint <code class="sig-name descname">getRank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image7getRankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get rank. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRank.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRank.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image18getFlattenedLengthEv">
<span id="_CPPv3NK3LLU5Image18getFlattenedLengthEv"></span><span id="_CPPv2NK3LLU5Image18getFlattenedLengthEv"></span><span id="LLU::Image::getFlattenedLengthC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1a73de9b9dda263b83edf03fc01c8e967a"></span>mint <code class="sig-name descname">getFlattenedLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image18getFlattenedLengthEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the total number of pixels in the image. </p>
<p><dl class="simple">
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getFlattenedLength.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getFlattenedLength.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4typeEv">
<span id="_CPPv3NK3LLU5Image4typeEv"></span><span id="_CPPv2NK3LLU5Image4typeEv"></span><span id="LLU::Image::typeC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1acd2311422ab186838cb279478679c7e1"></span>imagedata_t <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the data type of the image. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type of elements (see definition of <code class="docutils literal notranslate"><span class="pre">imagedata_t</span></code>) </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getDataType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getDataType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image7rawDataEv">
<span id="_CPPv3NK3LLU5Image7rawDataEv"></span><span id="_CPPv2NK3LLU5Image7rawDataEv"></span><span id="LLU::Image::rawDataC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4_1ab50949e739de8bb66e93f3ca6650db1a"></span>void *<code class="sig-name descname">rawData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU5Image7rawDataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get access to raw image data. </p>
<p>Use with caution. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to the raw data </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRawData.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MImage_getRawData.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image12getContainerEv">
<span id="_CPPv3NK3LLU5Image12getContainerEv"></span><span id="_CPPv2NK3LLU5Image12getContainerEv"></span><span id="LLU::Image::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU5Image9ContainerE" title="LLU::Image::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image16abandonContainerEv">
<span id="_CPPv3NK3LLU5Image16abandonContainerEv"></span><span id="_CPPv2NK3LLU5Image16abandonContainerEv"></span><span id="LLU::Image::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU5Image9ContainerE" title="LLU::Image::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image10shareCountEv">
<span id="_CPPv3NK3LLU5Image10shareCountEv"></span><span id="_CPPv2NK3LLU5Image10shareCountEv"></span><span id="LLU::Image::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image4passER9MArgument">
<span id="_CPPv3NK3LLU5Image4passER9MArgument"></span><span id="_CPPv2NK3LLU5Image4passER9MArgument"></span><span id="LLU::Image::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU5Image4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU5Image8getOwnerEv">
<span id="_CPPv3NK3LLU5Image8getOwnerEv"></span><span id="_CPPv2NK3LLU5Image8getOwnerEv"></span><span id="LLU::Image::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU5Image8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="llu-numericarray-t">
<span id="numarr-label"></span><h3><a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::NumericArray&lt;T&gt;</span></code></a><a class="headerlink" href="#llu-numericarray-t" title="Permalink to this headline"> 🔗</a></h3>
<p>NumericArray&lt;T&gt; is an extension of GenericNumericArray which is aware that it holds data of type T and therefore can provide an API
to iterate over the data and modify it.
The table below shows the correspondence between NumericArray C++ types and Wolfram Language types:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 51%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>C++ type</p></th>
<th class="head"><p>Wolfram Language type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>std::int8_t</p></td>
<td><p>“Integer8”</p></td>
</tr>
<tr class="row-odd"><td><p>std::uint8_t</p></td>
<td><p>“UnsignedInteger8”</p></td>
</tr>
<tr class="row-even"><td><p>std::int16_t</p></td>
<td><p>“Integer16”</p></td>
</tr>
<tr class="row-odd"><td><p>std::uint16_t</p></td>
<td><p>“UnsignedInteger16”</p></td>
</tr>
<tr class="row-even"><td><p>std::int32_t</p></td>
<td><p>“Integer32”</p></td>
</tr>
<tr class="row-odd"><td><p>std::uint32_t</p></td>
<td><p>“UnsignedInteger32”</p></td>
</tr>
<tr class="row-even"><td><p>std::int64_t</p></td>
<td><p>“Integer64”</p></td>
</tr>
<tr class="row-odd"><td><p>std::uint64_t</p></td>
<td><p>“UnsignedInteger64”</p></td>
</tr>
<tr class="row-even"><td><p>float</p></td>
<td><p>“Real32”</p></td>
</tr>
<tr class="row-odd"><td><p>double</p></td>
<td><p>“Real64”</p></td>
</tr>
<tr class="row-even"><td><p>std::complex&lt;float&gt;</p></td>
<td><p>“ComplexReal32”</p></td>
</tr>
<tr class="row-odd"><td><p>std::complex&lt;double&gt;</p></td>
<td><p>“ComplexReal64”</p></td>
</tr>
</tbody>
</table>
<p>Here is an example of the NumericArray class in action:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* Take a NumericArray of type &quot;Integer32&quot; and make a copy with reversed order of elements */</span>
<span class="n">LIBRARY_LINK_FUNCTION</span><span class="p">(</span><span class="n">ReverseNumericArray</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">MArgumentManager</span> <span class="n">mngr</span> <span class="p">{</span><span class="n">libData</span><span class="p">,</span> <span class="n">Argc</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Res</span><span class="p">};</span>
   <span class="k">auto</span> <span class="n">inputNA</span> <span class="o">=</span> <span class="n">mngr</span><span class="p">.</span><span class="n">getNumericArray</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int32_t</span><span class="p">,</span> <span class="n">LLU</span><span class="o">::</span><span class="n">Passing</span><span class="o">::</span><span class="n">Constant</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">NumericArray</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">outNA</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">crbegin</span><span class="p">(</span><span class="n">inputNA</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">crend</span><span class="p">(</span><span class="n">inputNA</span><span class="p">),</span> <span class="n">inputNA</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="p">};</span>
   <span class="n">mngr</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">outNA</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">LLU</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">NoError</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>On the Wolfram Language side, we can load and use this function as follows:</p>
<div class="highlight-wolfram-language notranslate"><div class="highlight"><pre><span></span><span class="nv">`LLU`PacletFunctionSet</span><span class="p">[</span><span class="nv">ReverseNumericArray</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ReverseNumericArray&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{{</span><span class="nb">NumericArray</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Constant&quot;</span><span class="p">}},</span><span class="w"> </span><span class="nb">NumericArray</span><span class="p">]</span><span class="o">;</span><span class="w"></span>

<span class="nv">ReverseNumericArray</span><span class="p">[</span><span class="nb">NumericArray</span><span class="p">[{{</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">}},</span><span class="w"> </span><span class="s">&quot;Integer32&quot;</span><span class="p">]]</span><span class="w"></span>

<span class="c">(* Out[] = NumericArray[{{7, 6, 5}, {4, 3, 2}}, &quot;Integer32&quot;] *)</span><span class="w"></span>
</pre></div>
</div>
<dl class="cpp class">
<dt id="_CPPv4I0EN3LLU12NumericArrayE">
<span id="_CPPv3I0EN3LLU12NumericArrayE"></span><span id="_CPPv2I0EN3LLU12NumericArrayE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classLLU_1_1NumericArray"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">NumericArray</code> : <em class="property">public</em> LLU::TypedNumericArray&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a>&gt;, <em class="property">public</em> LLU::<a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType12NumericArrayEEE" title="LLU::MContainer&lt;MArgumentType::NumericArray&gt;">MContainer</a>&lt;MArgumentType::NumericArray&gt;<a class="headerlink" href="#_CPPv4I0EN3LLU12NumericArrayE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>This is a class template, where template parameter T is the type of data elements. <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> is derived from MArray. </p>
<p>NumericArray&lt;&gt; classes automate creation and deletion of MNumericArrays. They are strongly typed (no void* to underlying memory) and almost all functions from &lt;algorithms&gt; can be used on <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a>.</p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: - type of underlying data </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU12NumericArray10value_typeE">
<span id="_CPPv3N3LLU12NumericArray10value_typeE"></span><span id="_CPPv2N3LLU12NumericArray10value_typeE"></span><span class="target" id="classLLU_1_1IterableContainer_1aae6a9d571c13ce824507d7787d316503"></span><em class="property">using </em><code class="sig-name descname">value_type</code> = <a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a><a class="headerlink" href="#_CPPv4N3LLU12NumericArray10value_typeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Type of elements stored. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU12NumericArray8iteratorE">
<span id="_CPPv3N3LLU12NumericArray8iteratorE"></span><span id="_CPPv2N3LLU12NumericArray8iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1ac8b597819b579738c0a276da4b8d33fc"></span><em class="property">using </em><code class="sig-name descname">iterator</code> = <a class="reference internal" href="#_CPPv4N3LLU12NumericArray10value_typeE" title="LLU::NumericArray::value_type">value_type</a>*<a class="headerlink" href="#_CPPv4N3LLU12NumericArray8iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU12NumericArray14const_iteratorE">
<span id="_CPPv3N3LLU12NumericArray14const_iteratorE"></span><span id="_CPPv2N3LLU12NumericArray14const_iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1a9a8695babde8c0d183f68cd3c95101f8"></span><em class="property">using </em><code class="sig-name descname">const_iterator</code> = <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU12NumericArray10value_typeE" title="LLU::NumericArray::value_type">value_type</a>*<a class="headerlink" href="#_CPPv4N3LLU12NumericArray14const_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constant iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU12NumericArray16reverse_iteratorE">
<span id="_CPPv3N3LLU12NumericArray16reverse_iteratorE"></span><span id="_CPPv2N3LLU12NumericArray16reverse_iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1a41529a4e72b6b181a2b39939b58bd15d"></span><em class="property">using </em><code class="sig-name descname">reverse_iterator</code> = std::reverse_iterator&lt;<a class="reference internal" href="#_CPPv4N3LLU12NumericArray8iteratorE" title="LLU::NumericArray::iterator">iterator</a>&gt;<a class="headerlink" href="#_CPPv4N3LLU12NumericArray16reverse_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Reverse iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU12NumericArray22const_reverse_iteratorE">
<span id="_CPPv3N3LLU12NumericArray22const_reverse_iteratorE"></span><span id="_CPPv2N3LLU12NumericArray22const_reverse_iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1a6f6c37582422b85f59ed4323eca98584"></span><em class="property">using </em><code class="sig-name descname">const_reverse_iterator</code> = std::reverse_iterator&lt;<a class="reference internal" href="#_CPPv4N3LLU12NumericArray14const_iteratorE" title="LLU::NumericArray::const_iterator">const_iterator</a>&gt;<a class="headerlink" href="#_CPPv4N3LLU12NumericArray22const_reverse_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constant reverse iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU12NumericArray9referenceE">
<span id="_CPPv3N3LLU12NumericArray9referenceE"></span><span id="_CPPv2N3LLU12NumericArray9referenceE"></span><span class="target" id="classLLU_1_1IterableContainer_1a434c506653af6c6a1da3af51ba478625"></span><em class="property">using </em><code class="sig-name descname">reference</code> = <a class="reference internal" href="#_CPPv4N3LLU12NumericArray10value_typeE" title="LLU::NumericArray::value_type">value_type</a>&amp;<a class="headerlink" href="#_CPPv4N3LLU12NumericArray9referenceE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Reference type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU12NumericArray15const_referenceE">
<span id="_CPPv3N3LLU12NumericArray15const_referenceE"></span><span id="_CPPv2N3LLU12NumericArray15const_referenceE"></span><span class="target" id="classLLU_1_1IterableContainer_1aa638ab9c633ff30d210c1c833a8b3c8f"></span><em class="property">using </em><code class="sig-name descname">const_reference</code> = <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU12NumericArray10value_typeE" title="LLU::NumericArray::value_type">value_type</a>&amp;<a class="headerlink" href="#_CPPv4N3LLU12NumericArray15const_referenceE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constant reference type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU12NumericArray9ContainerE">
<span id="_CPPv3N3LLU12NumericArray9ContainerE"></span><span id="_CPPv2N3LLU12NumericArray9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU12NumericArray9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray12NumericArrayENSt16initializer_listI1TEE">
<span id="_CPPv3N3LLU12NumericArray12NumericArrayENSt16initializer_listI1TEE"></span><span id="_CPPv2N3LLU12NumericArray12NumericArrayENSt16initializer_listI1TEE"></span><span id="LLU::NumericArray::NumericArray__std::initializer_list:T:"></span><span class="target" id="classLLU_1_1NumericArray_1a078691750ef23c4b7623427f0d2a1ecb"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span>std::initializer_list&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a>&gt; <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArray12NumericArrayENSt16initializer_listI1TEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs flat <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> based on a list of elements. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">v</span></code>: - initializer list with <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> elements </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">see</span></code>: NumericArray&lt;T&gt;::NumericArray(InputIt, InputIt, std::initializer_list&lt;mint&gt;)</p></li>
</ul>
</dd>
<dt><strong>Warning</strong></dt><dd><p>It is user’s responsibility to make sure that length of v fits into mint! </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN3LLU12NumericArray12NumericArrayERK9Container">
<span id="_CPPv3I00EN3LLU12NumericArray12NumericArrayERK9Container"></span><span id="_CPPv2I00EN3LLU12NumericArray12NumericArrayERK9Container"></span>template&lt;class <code class="sig-name descname">Container</code>, typename = std::enable_if_t&lt;is_iterable_container_with_matching_type_v&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayERK9Container" title="LLU::NumericArray::NumericArray::Container">Container</a>, <a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a>&gt; &amp;&amp; has_size_v&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayERK9Container" title="LLU::NumericArray::NumericArray::Container">Container</a>&gt;&gt;&gt;<br /><span class="target" id="classLLU_1_1NumericArray_1a6b0d484a8f2d3741d78a78451a93949c"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayERK9Container" title="LLU::NumericArray::NumericArray::Container">Container</a> &amp;<em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayERK9Container" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs flat <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> with contents copied from a given collection of data. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Container</span></code>: - any iterable (begin(), end()) collection of data that has a <code class="docutils literal notranslate"><span class="pre">value_type</span></code> alias member and a size() member function </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code>: - const reference to a collection from which data will be copied to the <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN3LLU12NumericArray12NumericArrayERK9Container16MArrayDimensions">
<span id="_CPPv3I00EN3LLU12NumericArray12NumericArrayERK9Container16MArrayDimensions"></span><span id="_CPPv2I00EN3LLU12NumericArray12NumericArrayERK9Container16MArrayDimensions"></span>template&lt;class <code class="sig-name descname">Container</code>, typename = std::enable_if_t&lt;is_iterable_container_with_matching_type_v&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayERK9Container16MArrayDimensions" title="LLU::NumericArray::NumericArray::Container">Container</a>, <a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a>&gt;&gt;&gt;<br /><span class="target" id="classLLU_1_1NumericArray_1a9efbd4fac029ad1c2417ac9037104614"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayERK9Container16MArrayDimensions" title="LLU::NumericArray::NumericArray::Container">Container</a> &amp;<em>c</em>, MArrayDimensions <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayERK9Container16MArrayDimensions" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs a <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> with contents copied from a given collection of data and dimensions passed as parameter. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Container</span></code>: - any iterable (begin(), end()) collection of data that has a <code class="docutils literal notranslate"><span class="pre">value_type</span></code> alias member </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code>: - const reference to a collection from which data will be copied to the <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dims</span></code>: - dimensions of the <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt">
<span id="_CPPv3I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt"></span><span id="_CPPv2I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt"></span>template&lt;class <code class="sig-name descname">InputIt</code>, typename = enable_if_input_iterator&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt" title="LLU::NumericArray::NumericArray::InputIt">InputIt</a>&gt;&gt;<br /><span class="target" id="classLLU_1_1NumericArray_1a1de7b7868e906a855165db3e0c81ab3c"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt" title="LLU::NumericArray::NumericArray::InputIt">InputIt</a> <em>first</em>, <a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt" title="LLU::NumericArray::NumericArray::InputIt">InputIt</a> <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs flat <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> with elements from range [first, last) </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">first</span></code>: - iterator to the beginning of range </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">last</span></code>: - iterator past the end of range </p></li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">InputIt</span></code>: - any iterator conforming to InputIterator concept </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">see</span></code>: NumericArray&lt;T&gt;::NumericArray(InputIt, InputIt, std::initializer_list&lt;mint&gt;)</p></li>
</ul>
</dd>
<dt><strong>Warning</strong></dt><dd><p>It is user’s responsibility to make sure that length of range fits into mint! </p>
</dd>
<dt><strong>Note</strong></dt><dd><p>Be aware that efficiency of this constructor strongly depends on whether the InputIt is also a RandomAccessIterator </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray12NumericArrayE1T16MArrayDimensions">
<span id="_CPPv3N3LLU12NumericArray12NumericArrayE1T16MArrayDimensions"></span><span id="_CPPv2N3LLU12NumericArray12NumericArrayE1T16MArrayDimensions"></span><span id="LLU::NumericArray::NumericArray__T.MArrayDimensions"></span><span class="target" id="classLLU_1_1NumericArray_1a31fa10dd757542e8df9ea30f564c9b50"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a> <em>init</em>, MArrayDimensions <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArray12NumericArrayE1T16MArrayDimensions" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs the <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> of given shape with all elements initialized to given value. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">init</span></code>: - value of type <strong>T</strong> to initialize all elements of the <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">dims</span></code>: - container with <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> dimensions </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt16MArrayDimensions">
<span id="_CPPv3I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt16MArrayDimensions"></span><span id="_CPPv2I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt16MArrayDimensions"></span>template&lt;class <code class="sig-name descname">InputIt</code>, typename = enable_if_input_iterator&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt16MArrayDimensions" title="LLU::NumericArray::NumericArray::InputIt">InputIt</a>&gt;&gt;<br /><span class="target" id="classLLU_1_1NumericArray_1a2b63412af82c7ecc083b1393ee51d28c"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt16MArrayDimensions" title="LLU::NumericArray::NumericArray::InputIt">InputIt</a> <em>first</em>, <a class="reference internal" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt16MArrayDimensions" title="LLU::NumericArray::NumericArray::InputIt">InputIt</a> <em>last</em>, MArrayDimensions <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3LLU12NumericArray12NumericArrayE7InputIt7InputIt16MArrayDimensions" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs the <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> of given shape with elements from range [first, last) </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">first</span></code>: - iterator to the beginning of range </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">last</span></code>: - iterator past the end of range </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">dims</span></code>: - container with <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> dimensions </p></li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Container</span></code>: - any type of container that has member <strong>value_type</strong> and this type is convertible to mint </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::NumericArrayNewError</span></code>: - if number of elements in <code class="docutils literal notranslate"><span class="pre">v</span></code> does not match total <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> size indicated by <code class="docutils literal notranslate"><span class="pre">dims</span></code> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">see</span></code>: NumericArray&lt;T&gt;::createInternal() and MArray&lt;T&gt;::MArray(Container&amp;&amp;) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray12NumericArrayE13MNumericArray9Ownership">
<span id="_CPPv3N3LLU12NumericArray12NumericArrayE13MNumericArray9Ownership"></span><span id="_CPPv2N3LLU12NumericArray12NumericArrayE13MNumericArray9Ownership"></span><span id="LLU::NumericArray::NumericArray__MNumericArray.Ownership"></span><span class="target" id="classLLU_1_1NumericArray_1a5d98ff3fc159a09f2b49281a0db76d5f"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span>MNumericArray <em>na</em>, <a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArray12NumericArrayE13MNumericArray9Ownership" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> based on MNumericArray. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">na</span></code>: - LibraryLink structure to be wrapped </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">owner</span></code>: - who manages the memory the raw MNumericArray </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::NumericArrayTypeError</span></code>: - if the <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> template type <strong>T</strong> does not match the actual data type of the MNumericArray </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray12NumericArrayE19GenericNumericArray">
<span id="_CPPv3N3LLU12NumericArray12NumericArrayE19GenericNumericArray"></span><span id="_CPPv2N3LLU12NumericArray12NumericArrayE19GenericNumericArray"></span><span id="LLU::NumericArray::NumericArray__GenericNumericArray"></span><span class="target" id="classLLU_1_1NumericArray_1af2887e78b1cead328b0e1553586241e3"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N3LLU19GenericNumericArrayE" title="LLU::GenericNumericArray">GenericNumericArray</a> <em>na</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArray12NumericArrayE19GenericNumericArray" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create new <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> from a GenericNumericArray. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">na</span></code>: - generic <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> to be wrapped into <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> class </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::NumericArrayTypeError</span></code>: - if the <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> template type <strong>T</strong> does not match the actual data type of the generic <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray12NumericArrayERK19GenericNumericArrayN2NA16ConversionMethodEd">
<span id="_CPPv3N3LLU12NumericArray12NumericArrayERK19GenericNumericArrayN2NA16ConversionMethodEd"></span><span id="_CPPv2N3LLU12NumericArray12NumericArrayERK19GenericNumericArrayN2NA16ConversionMethodEd"></span><span id="LLU::NumericArray::NumericArray__GenericNumericArrayCR.NA::ConversionMethod.double"></span><span class="target" id="classLLU_1_1NumericArray_1aca0f7b81a8f247f5449397cca8eebf5d"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU19GenericNumericArrayE" title="LLU::GenericNumericArray">GenericNumericArray</a> &amp;<em>other</em>, NA::ConversionMethod <em>method</em>, double <em>param</em> = 0.0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArray12NumericArrayERK19GenericNumericArrayN2NA16ConversionMethodEd" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> from generic <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a>. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">other</span></code>: - const reference to a generic <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">method</span></code>: - conversion method to be used, when in doubt use NA::ConversionMethod::ClipRound as default </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">param</span></code>: - conversion tolerance </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray12NumericArrayEv">
<span id="_CPPv3N3LLU12NumericArray12NumericArrayEv"></span><span id="_CPPv2N3LLU12NumericArray12NumericArrayEv"></span><span id="LLU::NumericArray::NumericArray"></span><span class="target" id="classLLU_1_1NumericArray_1a704c4703caceb6f56f98fcd61a413b1c"></span><code class="sig-name descname">NumericArray</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N3LLU12NumericArray12NumericArrayEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default constructor, creates a “hollow” <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> that does not have underlying MNumericArray. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray5cloneEv">
<span id="_CPPv3NK3LLU12NumericArray5cloneEv"></span><span id="_CPPv2NK3LLU12NumericArray5cloneEv"></span><span id="LLU::NumericArray::cloneC"></span><span class="target" id="classLLU_1_1NumericArray_1a5ba1cd8197f6d6db1d707600016f3b3e"></span><a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray">NumericArray</a> <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a>, performing a deep copy of the underlying MNumericArray. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned MNumericArray always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new <a class="reference internal" href="#classLLU_1_1NumericArray"><span class="std std-ref">NumericArray</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray4rankEv">
<span id="_CPPv3NK3LLU12NumericArray4rankEv"></span><span id="_CPPv2NK3LLU12NumericArray4rankEv"></span><span id="LLU::NumericArray::rankC"></span><span class="target" id="classLLU_1_1MArray_1a6a1f85549f320f4ccce4b8957495851a"></span>mint <code class="sig-name descname">rank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray4rankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get container rank. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray5emptyEv">
<span id="_CPPv3NK3LLU12NumericArray5emptyEv"></span><span id="_CPPv2NK3LLU12NumericArray5emptyEv"></span><span id="LLU::NumericArray::emptyC"></span><span class="target" id="classLLU_1_1MArray_1ad0660a7856ffd2ebb931a75a09b7dca7"></span>bool <code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray5emptyEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check whether container is empty. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray9dimensionE4mint">
<span id="_CPPv3NK3LLU12NumericArray9dimensionE4mint"></span><span id="_CPPv2NK3LLU12NumericArray9dimensionE4mint"></span><span id="LLU::NumericArray::dimension__mintC"></span><span class="target" id="classLLU_1_1MArray_1a44e07e472aa8c85ff60a7afcb005da71"></span>mint <code class="sig-name descname">dimension</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray9dimensionE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get dimension value at position <code class="docutils literal notranslate"><span class="pre">index</span></code>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray10dimensionsEv">
<span id="_CPPv3NK3LLU12NumericArray10dimensionsEv"></span><span id="_CPPv2NK3LLU12NumericArray10dimensionsEv"></span><span id="LLU::NumericArray::dimensionsC"></span><span class="target" id="classLLU_1_1MArray_1aee9a5b13a2234e858a788cf917843814"></span><em class="property">const</em> MArrayDimensions &amp;<code class="sig-name descname">dimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray10dimensionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a const reference to dimensions object. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArrayixERKNSt6vectorI4mintEE">
<span id="_CPPv3N3LLU12NumericArrayixERKNSt6vectorI4mintEE"></span><span id="_CPPv2N3LLU12NumericArrayixERKNSt6vectorI4mintEE"></span><span id="LLU::NumericArray::subscript-operator__std::vector:mint:CR"></span><span class="target" id="classLLU_1_1MArray_1ad649b2993c695ce2b102f4138c7758f8"></span><a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a> &amp;<code class="sig-name descname">operator[]</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArrayixERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArrayixERKNSt6vectorI4mintEE">
<span id="_CPPv3NK3LLU12NumericArrayixERKNSt6vectorI4mintEE"></span><span id="_CPPv2NK3LLU12NumericArrayixERKNSt6vectorI4mintEE"></span><span id="LLU::NumericArray::subscript-operator__std::vector:mint:CRC"></span><span class="target" id="classLLU_1_1MArray_1a22590ae040ce13a69fc6dcf1a7064aab"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a> &amp;<code class="sig-name descname">operator[]</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArrayixERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArrayixE4mint">
<span id="_CPPv3N3LLU12NumericArrayixE4mint"></span><span id="_CPPv2N3LLU12NumericArrayixE4mint"></span><span id="LLU::NumericArray::subscript-operator__mint"></span><span class="target" id="classLLU_1_1IterableContainer_1a19a4221532b5d35e22b6573d46b87f80"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray9referenceE" title="LLU::NumericArray::reference">reference</a> <code class="sig-name descname">operator[]</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArrayixE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArrayixE4mint">
<span id="_CPPv3NK3LLU12NumericArrayixE4mint"></span><span id="_CPPv2NK3LLU12NumericArrayixE4mint"></span><span id="LLU::NumericArray::subscript-operator__mintC"></span><span class="target" id="classLLU_1_1IterableContainer_1a548d4460ce2474312c61ea7ad0b088f9"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray15const_referenceE" title="LLU::NumericArray::const_reference">const_reference</a> <code class="sig-name descname">operator[]</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArrayixE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray2atE4mint">
<span id="_CPPv3N3LLU12NumericArray2atE4mint"></span><span id="_CPPv2N3LLU12NumericArray2atE4mint"></span><span id="LLU::NumericArray::at__mint"></span><span class="target" id="classLLU_1_1MArray_1a709e1c06e4891e210bca65c67cdbaad2"></span><a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArray2atE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position with bound checking. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">index</span></code> is out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray2atE4mint">
<span id="_CPPv3NK3LLU12NumericArray2atE4mint"></span><span id="_CPPv2NK3LLU12NumericArray2atE4mint"></span><span id="LLU::NumericArray::at__mintC"></span><span class="target" id="classLLU_1_1MArray_1a4eba03b34a730d7a372ebd4081409509"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray2atE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position with bound checking. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">index</span></code> is out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray2atERKNSt6vectorI4mintEE">
<span id="_CPPv3N3LLU12NumericArray2atERKNSt6vectorI4mintEE"></span><span id="_CPPv2N3LLU12NumericArray2atERKNSt6vectorI4mintEE"></span><span id="LLU::NumericArray::at__std::vector:mint:CR"></span><span class="target" id="classLLU_1_1MArray_1a97b1d5b38f646fb55c0855699f648012"></span><a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArray2atERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">indices</span></code> are out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray2atERKNSt6vectorI4mintEE">
<span id="_CPPv3NK3LLU12NumericArray2atERKNSt6vectorI4mintEE"></span><span id="_CPPv2NK3LLU12NumericArray2atERKNSt6vectorI4mintEE"></span><span id="LLU::NumericArray::at__std::vector:mint:CRC"></span><span class="target" id="classLLU_1_1MArray_1a336ad439eabceff0ec49bcd01ff5e251"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray2atERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">indices</span></code> are out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray4dataEv">
<span id="_CPPv3N3LLU12NumericArray4dataEv"></span><span id="_CPPv2N3LLU12NumericArray4dataEv"></span><span id="LLU::NumericArray::data"></span><span class="target" id="classLLU_1_1IterableContainer_1a1f9294306bb0f09963859cbf5a395e4b"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray10value_typeE" title="LLU::NumericArray::value_type">value_type</a> *<code class="sig-name descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU12NumericArray4dataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get raw pointer to underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray4dataEv">
<span id="_CPPv3NK3LLU12NumericArray4dataEv"></span><span id="_CPPv2NK3LLU12NumericArray4dataEv"></span><span id="LLU::NumericArray::dataC"></span><span class="target" id="classLLU_1_1IterableContainer_1ad074c86ef619bc6354b37018e7b55a18"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU12NumericArray10value_typeE" title="LLU::NumericArray::value_type">value_type</a> *<code class="sig-name descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray4dataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get raw pointer to const underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray4sizeEv">
<span id="_CPPv3NK3LLU12NumericArray4sizeEv"></span><span id="_CPPv2NK3LLU12NumericArray4sizeEv"></span><span id="LLU::NumericArray::sizeC"></span><span class="target" id="classLLU_1_1IterableContainer_1ab3046c61f8bb0e1db83ec4907fbc5087"></span>mint <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray4sizeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get total number of elements in the container. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray5beginEv">
<span id="_CPPv3N3LLU12NumericArray5beginEv"></span><span id="_CPPv2N3LLU12NumericArray5beginEv"></span><span id="LLU::NumericArray::begin"></span><span class="target" id="classLLU_1_1IterableContainer_1adbbf7628ba97cdb30fe78000d2b5fc20"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray8iteratorE" title="LLU::NumericArray::iterator">iterator</a> <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU12NumericArray5beginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray5beginEv">
<span id="_CPPv3NK3LLU12NumericArray5beginEv"></span><span id="_CPPv2NK3LLU12NumericArray5beginEv"></span><span id="LLU::NumericArray::beginC"></span><span class="target" id="classLLU_1_1IterableContainer_1ac107dad385fa41d1853766bc6ef249ec"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray14const_iteratorE" title="LLU::NumericArray::const_iterator">const_iterator</a> <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray5beginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray6cbeginEv">
<span id="_CPPv3NK3LLU12NumericArray6cbeginEv"></span><span id="_CPPv2NK3LLU12NumericArray6cbeginEv"></span><span id="LLU::NumericArray::cbeginC"></span><span class="target" id="classLLU_1_1IterableContainer_1a58ec84224bf0e8ca8927e4553cb8afb8"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray14const_iteratorE" title="LLU::NumericArray::const_iterator">const_iterator</a> <code class="sig-name descname">cbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray6cbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray3endEv">
<span id="_CPPv3N3LLU12NumericArray3endEv"></span><span id="_CPPv2N3LLU12NumericArray3endEv"></span><span id="LLU::NumericArray::end"></span><span class="target" id="classLLU_1_1IterableContainer_1a9bd4ff608c8087acd4abae3df8c177e8"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray8iteratorE" title="LLU::NumericArray::iterator">iterator</a> <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU12NumericArray3endEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray3endEv">
<span id="_CPPv3NK3LLU12NumericArray3endEv"></span><span id="_CPPv2NK3LLU12NumericArray3endEv"></span><span id="LLU::NumericArray::endC"></span><span class="target" id="classLLU_1_1IterableContainer_1af0164d7e75cc5b8c3ae7b7625e75ccbd"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray14const_iteratorE" title="LLU::NumericArray::const_iterator">const_iterator</a> <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray3endEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray4cendEv">
<span id="_CPPv3NK3LLU12NumericArray4cendEv"></span><span id="_CPPv2NK3LLU12NumericArray4cendEv"></span><span id="LLU::NumericArray::cendC"></span><span class="target" id="classLLU_1_1IterableContainer_1a5734bc636b9edca9dda9e7ac69c50d37"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray14const_iteratorE" title="LLU::NumericArray::const_iterator">const_iterator</a> <code class="sig-name descname">cend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray4cendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray6rbeginEv">
<span id="_CPPv3N3LLU12NumericArray6rbeginEv"></span><span id="_CPPv2N3LLU12NumericArray6rbeginEv"></span><span id="LLU::NumericArray::rbegin"></span><span class="target" id="classLLU_1_1IterableContainer_1a5d59ccc0e700a96c51045f0d5ee69883"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray16reverse_iteratorE" title="LLU::NumericArray::reverse_iterator">reverse_iterator</a> <code class="sig-name descname">rbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU12NumericArray6rbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray6rbeginEv">
<span id="_CPPv3NK3LLU12NumericArray6rbeginEv"></span><span id="_CPPv2NK3LLU12NumericArray6rbeginEv"></span><span id="LLU::NumericArray::rbeginC"></span><span class="target" id="classLLU_1_1IterableContainer_1a177fe159a37bbaf8eb8546b26fb0f9e3"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray22const_reverse_iteratorE" title="LLU::NumericArray::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">rbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray6rbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray7crbeginEv">
<span id="_CPPv3NK3LLU12NumericArray7crbeginEv"></span><span id="_CPPv2NK3LLU12NumericArray7crbeginEv"></span><span id="LLU::NumericArray::crbeginC"></span><span class="target" id="classLLU_1_1IterableContainer_1a03798d561430d17054f801bcf4ca4510"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray22const_reverse_iteratorE" title="LLU::NumericArray::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">crbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray7crbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray4rendEv">
<span id="_CPPv3N3LLU12NumericArray4rendEv"></span><span id="_CPPv2N3LLU12NumericArray4rendEv"></span><span id="LLU::NumericArray::rend"></span><span class="target" id="classLLU_1_1IterableContainer_1adc895d42aa8cb4e1fa3145eb9f83a5fb"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray16reverse_iteratorE" title="LLU::NumericArray::reverse_iterator">reverse_iterator</a> <code class="sig-name descname">rend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU12NumericArray4rendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray4rendEv">
<span id="_CPPv3NK3LLU12NumericArray4rendEv"></span><span id="_CPPv2NK3LLU12NumericArray4rendEv"></span><span id="LLU::NumericArray::rendC"></span><span class="target" id="classLLU_1_1IterableContainer_1af053c33d89fc05f1c9368df1b6a5d00d"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray22const_reverse_iteratorE" title="LLU::NumericArray::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">rend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray4rendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray5crendEv">
<span id="_CPPv3NK3LLU12NumericArray5crendEv"></span><span id="_CPPv2NK3LLU12NumericArray5crendEv"></span><span id="LLU::NumericArray::crendC"></span><span class="target" id="classLLU_1_1IterableContainer_1ac6a8810748705c2359a379dab9f3c396"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray22const_reverse_iteratorE" title="LLU::NumericArray::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">crend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray5crendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray5frontEv">
<span id="_CPPv3N3LLU12NumericArray5frontEv"></span><span id="_CPPv2N3LLU12NumericArray5frontEv"></span><span id="LLU::NumericArray::front"></span><span class="target" id="classLLU_1_1IterableContainer_1af22c6027070c7fd150bb86a53d8f50de"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray9referenceE" title="LLU::NumericArray::reference">reference</a> <code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArray5frontEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get reference to the first element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray5frontEv">
<span id="_CPPv3NK3LLU12NumericArray5frontEv"></span><span id="_CPPv2NK3LLU12NumericArray5frontEv"></span><span id="LLU::NumericArray::frontC"></span><span class="target" id="classLLU_1_1IterableContainer_1ad11d7f07a4e7ff56818d4b038646525d"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray15const_referenceE" title="LLU::NumericArray::const_reference">const_reference</a> <code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray5frontEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant reference to the first element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NumericArray4backEv">
<span id="_CPPv3N3LLU12NumericArray4backEv"></span><span id="_CPPv2N3LLU12NumericArray4backEv"></span><span id="LLU::NumericArray::back"></span><span class="target" id="classLLU_1_1IterableContainer_1abcde345515a1529d00d7f35bdd3c428e"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray9referenceE" title="LLU::NumericArray::reference">reference</a> <code class="sig-name descname">back</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NumericArray4backEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get reference to the last element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray4backEv">
<span id="_CPPv3NK3LLU12NumericArray4backEv"></span><span id="_CPPv2NK3LLU12NumericArray4backEv"></span><span id="LLU::NumericArray::backC"></span><span class="target" id="classLLU_1_1IterableContainer_1a74006685a7c15be6030f7217d761280a"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray15const_referenceE" title="LLU::NumericArray::const_reference">const_reference</a> <code class="sig-name descname">back</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray4backEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant reference to the last element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray8asVectorEv">
<span id="_CPPv3NK3LLU12NumericArray8asVectorEv"></span><span id="_CPPv2NK3LLU12NumericArray8asVectorEv"></span><span id="LLU::NumericArray::asVectorC"></span><span class="target" id="classLLU_1_1IterableContainer_1af66aee992031feec7f2c41a50b71a8b6"></span>std::vector&lt;<a class="reference internal" href="#_CPPv4N3LLU12NumericArray10value_typeE" title="LLU::NumericArray::value_type">value_type</a>&gt; <code class="sig-name descname">asVector</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray8asVectorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Copy contents of the data to a std::vector of matching type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>std::vector with the copy of the data </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray7convertE19numericarray_data_tN2NA16ConversionMethodEd">
<span id="_CPPv3NK3LLU12NumericArray7convertE19numericarray_data_tN2NA16ConversionMethodEd"></span><span id="_CPPv2NK3LLU12NumericArray7convertE19numericarray_data_tN2NA16ConversionMethodEd"></span><span id="LLU::NumericArray::convert__numericarray_data_t.NA::ConversionMethod.doubleC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1a31bd8cf6a865be602b8492738fdbad94"></span><a class="reference internal" href="#_CPPv4N3LLU19GenericNumericArrayE" title="LLU::GenericNumericArray">GenericNumericArray</a> <code class="sig-name descname">convert</code><span class="sig-paren">(</span>numericarray_data_t <em>t</em>, NA::ConversionMethod <em>method</em>, double <em>param</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray7convertE19numericarray_data_tN2NA16ConversionMethodEd" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Convert this object to a new GenericNumericArray of given datatype, using specified conversion method. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: - destination data type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>: - conversion method </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">param</span></code>: - conversion method parameter (aka tolerance) </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>converted GenericNumericArray owned by the Library </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_convertType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_convertType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray7getRankEv">
<span id="_CPPv3NK3LLU12NumericArray7getRankEv"></span><span id="_CPPv2NK3LLU12NumericArray7getRankEv"></span><span id="LLU::NumericArray::getRankC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1abbc354b8727bb4769df5e087b34d186c"></span>mint <code class="sig-name descname">getRank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray7getRankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get rank. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>number of dimensions in the array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getRank.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getRank.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray13getDimensionsEv">
<span id="_CPPv3NK3LLU12NumericArray13getDimensionsEv"></span><span id="_CPPv2NK3LLU12NumericArray13getDimensionsEv"></span><span id="LLU::NumericArray::getDimensionsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1ab5c213e75fb568c729dbdcdd77acda0f"></span>mint <em class="property">const</em> *<code class="sig-name descname">getDimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray13getDimensionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get dimensions. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>raw pointer to dimensions of the array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getDimensions.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getDimensions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray18getFlattenedLengthEv">
<span id="_CPPv3NK3LLU12NumericArray18getFlattenedLengthEv"></span><span id="_CPPv2NK3LLU12NumericArray18getFlattenedLengthEv"></span><span id="LLU::NumericArray::getFlattenedLengthC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1a8a28c51ced9dee034006ef3ead751060"></span>mint <code class="sig-name descname">getFlattenedLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray18getFlattenedLengthEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get length. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>total number of elements </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getFlattenedLength.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getFlattenedLength.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray4typeEv">
<span id="_CPPv3NK3LLU12NumericArray4typeEv"></span><span id="_CPPv2NK3LLU12NumericArray4typeEv"></span><span id="LLU::NumericArray::typeC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1ab2ef63a6ffa7b34c058daf4ca3303e5a"></span>numericarray_data_t <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the data type of this array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type of elements (see definition of <code class="docutils literal notranslate"><span class="pre">numericarray_data_t</span></code>) </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getDataType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getDataType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray7rawDataEv">
<span id="_CPPv3NK3LLU12NumericArray7rawDataEv"></span><span id="_CPPv2NK3LLU12NumericArray7rawDataEv"></span><span id="LLU::NumericArray::rawDataC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4_1a71a50a2beea248ba58238e3c0435ac43"></span>void *<code class="sig-name descname">rawData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray7rawDataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get access to the raw data. </p>
<p>Use with caution. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>pointer to the raw data </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getData.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MNumericArray_getData.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray12getContainerEv">
<span id="_CPPv3NK3LLU12NumericArray12getContainerEv"></span><span id="_CPPv2NK3LLU12NumericArray12getContainerEv"></span><span id="LLU::NumericArray::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray9ContainerE" title="LLU::NumericArray::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray16abandonContainerEv">
<span id="_CPPv3NK3LLU12NumericArray16abandonContainerEv"></span><span id="_CPPv2NK3LLU12NumericArray16abandonContainerEv"></span><span id="LLU::NumericArray::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU12NumericArray9ContainerE" title="LLU::NumericArray::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray10shareCountEv">
<span id="_CPPv3NK3LLU12NumericArray10shareCountEv"></span><span id="_CPPv2NK3LLU12NumericArray10shareCountEv"></span><span id="LLU::NumericArray::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray4passER9MArgument">
<span id="_CPPv3NK3LLU12NumericArray4passER9MArgument"></span><span id="_CPPv2NK3LLU12NumericArray4passER9MArgument"></span><span id="LLU::NumericArray::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NumericArray8getOwnerEv">
<span id="_CPPv3NK3LLU12NumericArray8getOwnerEv"></span><span id="_CPPv2NK3LLU12NumericArray8getOwnerEv"></span><span id="LLU::NumericArray::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU12NumericArray8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="llu-tensor-t">
<span id="tensor-label"></span><h3><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::Tensor&lt;T&gt;</span></code></a><a class="headerlink" href="#llu-tensor-t" title="Permalink to this headline"> 🔗</a></h3>
<p>In the same way as MTensor is closely related to MNumericArray, <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">LLU</span><span class="pre">::</span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor"><span class="pre">Tensor</span></a></code> has almost exactly the same interface as <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">LLU</span><span class="pre">::</span><a class="reference internal" href="#_CPPv4I0EN3LLU12NumericArrayE" title="LLU::NumericArray"><span class="pre">NumericArray</span></a></code>.
Tensor supports only 3 types of data, meaning that <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">LLU::Tensor</span></code></a> class template can be instantiated with only 3 types <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mint</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::complex&lt;double&gt;</span></code></p></li>
</ul>
</div></blockquote>
<p>Here is an example of the Tensor class in action:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* Take a Tensor of real numbers and return the mean value */</span>
<span class="n">LIBRARY_LINK_FUNCTION</span><span class="p">(</span><span class="n">GetMeanValue</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">MArgumentManager</span> <span class="n">mngr</span> <span class="p">{</span><span class="n">libData</span><span class="p">,</span> <span class="n">Argc</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Res</span><span class="p">};</span>

   <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mngr</span><span class="p">.</span><span class="n">getTensor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

   <span class="k">auto</span> <span class="n">total</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">);</span>

   <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
   <span class="n">mngr</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">LLU</span><span class="o">::</span><span class="n">ErrorCode</span><span class="o">::</span><span class="n">NoError</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>On the Wolfram Language side, we can load and use this function as follows:</p>
<div class="highlight-wolfram-language notranslate"><div class="highlight"><pre><span></span><span class="nv">`LLU`PacletFunctionSet</span><span class="p">[</span><span class="nv">MeanValue</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MeanValue&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{{</span><span class="nb">Real</span><span class="p">,</span><span class="w"> </span><span class="o">_</span><span class="p">}},</span><span class="w"> </span><span class="nb">Real</span><span class="p">]</span><span class="o">;</span><span class="w"></span>

<span class="nv">MeanValue</span><span class="p">[</span><span class="nb">N</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="p">{{</span><span class="nb">Pi</span><span class="p">,</span><span class="w"> </span><span class="nb">Pi</span><span class="p">,</span><span class="w"> </span><span class="nb">Pi</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="nb">E</span><span class="p">,</span><span class="w"> </span><span class="nb">E</span><span class="p">,</span><span class="w"> </span><span class="nb">E</span><span class="p">}}]</span><span class="w"></span>

<span class="c">(* Out[] = 2.9299372 *)</span><span class="w"></span>
</pre></div>
</div>
<dl class="cpp class">
<dt id="_CPPv4I0EN3LLU6TensorE">
<span id="_CPPv3I0EN3LLU6TensorE"></span><span id="_CPPv2I0EN3LLU6TensorE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classLLU_1_1Tensor"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Tensor</code> : <em class="property">public</em> LLU::TypedTensor&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a>&gt;, <em class="property">public</em> LLU::<a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType6TensorEEE" title="LLU::MContainer&lt;MArgumentType::Tensor&gt;">MContainer</a>&lt;MArgumentType::Tensor&gt;<a class="headerlink" href="#_CPPv4I0EN3LLU6TensorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>This is a class template, where template parameter T is the type of data elements. <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> is derived from MArray. </p>
<p>Tensor&lt;&gt; classes automate creation and deletion of MTensors. They are strongly typed (no void* to underlying memory) and almost all functions from &lt;algorithms&gt; can be used on <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a>.</p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: - type of underlying data </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU6Tensor10value_typeE">
<span id="_CPPv3N3LLU6Tensor10value_typeE"></span><span id="_CPPv2N3LLU6Tensor10value_typeE"></span><span class="target" id="classLLU_1_1IterableContainer_1aae6a9d571c13ce824507d7787d316503"></span><em class="property">using </em><code class="sig-name descname">value_type</code> = <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a><a class="headerlink" href="#_CPPv4N3LLU6Tensor10value_typeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Type of elements stored. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU6Tensor8iteratorE">
<span id="_CPPv3N3LLU6Tensor8iteratorE"></span><span id="_CPPv2N3LLU6Tensor8iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1ac8b597819b579738c0a276da4b8d33fc"></span><em class="property">using </em><code class="sig-name descname">iterator</code> = <a class="reference internal" href="#_CPPv4N3LLU6Tensor10value_typeE" title="LLU::Tensor::value_type">value_type</a>*<a class="headerlink" href="#_CPPv4N3LLU6Tensor8iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU6Tensor14const_iteratorE">
<span id="_CPPv3N3LLU6Tensor14const_iteratorE"></span><span id="_CPPv2N3LLU6Tensor14const_iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1a9a8695babde8c0d183f68cd3c95101f8"></span><em class="property">using </em><code class="sig-name descname">const_iterator</code> = <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU6Tensor10value_typeE" title="LLU::Tensor::value_type">value_type</a>*<a class="headerlink" href="#_CPPv4N3LLU6Tensor14const_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constant iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU6Tensor16reverse_iteratorE">
<span id="_CPPv3N3LLU6Tensor16reverse_iteratorE"></span><span id="_CPPv2N3LLU6Tensor16reverse_iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1a41529a4e72b6b181a2b39939b58bd15d"></span><em class="property">using </em><code class="sig-name descname">reverse_iterator</code> = std::reverse_iterator&lt;<a class="reference internal" href="#_CPPv4N3LLU6Tensor8iteratorE" title="LLU::Tensor::iterator">iterator</a>&gt;<a class="headerlink" href="#_CPPv4N3LLU6Tensor16reverse_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Reverse iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU6Tensor22const_reverse_iteratorE">
<span id="_CPPv3N3LLU6Tensor22const_reverse_iteratorE"></span><span id="_CPPv2N3LLU6Tensor22const_reverse_iteratorE"></span><span class="target" id="classLLU_1_1IterableContainer_1a6f6c37582422b85f59ed4323eca98584"></span><em class="property">using </em><code class="sig-name descname">const_reverse_iterator</code> = std::reverse_iterator&lt;<a class="reference internal" href="#_CPPv4N3LLU6Tensor14const_iteratorE" title="LLU::Tensor::const_iterator">const_iterator</a>&gt;<a class="headerlink" href="#_CPPv4N3LLU6Tensor22const_reverse_iteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constant reverse iterator type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU6Tensor9referenceE">
<span id="_CPPv3N3LLU6Tensor9referenceE"></span><span id="_CPPv2N3LLU6Tensor9referenceE"></span><span class="target" id="classLLU_1_1IterableContainer_1a434c506653af6c6a1da3af51ba478625"></span><em class="property">using </em><code class="sig-name descname">reference</code> = <a class="reference internal" href="#_CPPv4N3LLU6Tensor10value_typeE" title="LLU::Tensor::value_type">value_type</a>&amp;<a class="headerlink" href="#_CPPv4N3LLU6Tensor9referenceE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Reference type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU6Tensor15const_referenceE">
<span id="_CPPv3N3LLU6Tensor15const_referenceE"></span><span id="_CPPv2N3LLU6Tensor15const_referenceE"></span><span class="target" id="classLLU_1_1IterableContainer_1aa638ab9c633ff30d210c1c833a8b3c8f"></span><em class="property">using </em><code class="sig-name descname">const_reference</code> = <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU6Tensor10value_typeE" title="LLU::Tensor::value_type">value_type</a>&amp;<a class="headerlink" href="#_CPPv4N3LLU6Tensor15const_referenceE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constant reference type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU6Tensor9ContainerE">
<span id="_CPPv3N3LLU6Tensor9ContainerE"></span><span id="_CPPv2N3LLU6Tensor9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU6Tensor9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor6TensorENSt16initializer_listI1TEE">
<span id="_CPPv3N3LLU6Tensor6TensorENSt16initializer_listI1TEE"></span><span id="_CPPv2N3LLU6Tensor6TensorENSt16initializer_listI1TEE"></span><span id="LLU::Tensor::Tensor__std::initializer_list:T:"></span><span class="target" id="classLLU_1_1Tensor_1aaf4b6a9d6c999cee6c276879b84887cf"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span>std::initializer_list&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a>&gt; <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6Tensor6TensorENSt16initializer_listI1TEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs flat <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> based on a list of elements. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">v</span></code>: - initializer list with <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> elements </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">see</span></code>: Tensor&lt;T&gt;::Tensor(InputIt, InputIt, std::initializer_list&lt;mint&gt;)</p></li>
</ul>
</dd>
<dt><strong>Warning</strong></dt><dd><p>It is user’s responsibility to make sure that length of v fits into mint! </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN3LLU6Tensor6TensorERK9Container">
<span id="_CPPv3I00EN3LLU6Tensor6TensorERK9Container"></span><span id="_CPPv2I00EN3LLU6Tensor6TensorERK9Container"></span>template&lt;class <code class="sig-name descname">Container</code>, typename = std::enable_if_t&lt;is_iterable_container_with_matching_type_v&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorERK9Container" title="LLU::Tensor::Tensor::Container">Container</a>, <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a>&gt; &amp;&amp; has_size_v&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorERK9Container" title="LLU::Tensor::Tensor::Container">Container</a>&gt;&gt;&gt;<br /><span class="target" id="classLLU_1_1Tensor_1a1135aeddd1caf89047b74143684ac744"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorERK9Container" title="LLU::Tensor::Tensor::Container">Container</a> &amp;<em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3LLU6Tensor6TensorERK9Container" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs flat <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> with contents copied from a given collection of data. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Container</span></code>: - any iterable (begin(), end()) collection of data that has a <code class="docutils literal notranslate"><span class="pre">value_type</span></code> alias member and a size() member function </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code>: - const reference to a collection from which data will be copied to the <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN3LLU6Tensor6TensorERK9Container16MArrayDimensions">
<span id="_CPPv3I00EN3LLU6Tensor6TensorERK9Container16MArrayDimensions"></span><span id="_CPPv2I00EN3LLU6Tensor6TensorERK9Container16MArrayDimensions"></span>template&lt;class <code class="sig-name descname">Container</code>, typename = std::enable_if_t&lt;is_iterable_container_with_matching_type_v&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorERK9Container16MArrayDimensions" title="LLU::Tensor::Tensor::Container">Container</a>, <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a>&gt;&gt;&gt;<br /><span class="target" id="classLLU_1_1Tensor_1a2d934c44aa9222110e7894cfefc43225"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorERK9Container16MArrayDimensions" title="LLU::Tensor::Tensor::Container">Container</a> &amp;<em>c</em>, MArrayDimensions <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3LLU6Tensor6TensorERK9Container16MArrayDimensions" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs a <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> with contents copied from a given collection of data and dimensions passed as parameter. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Container</span></code>: - any iterable (begin(), end()) collection of data that has a <code class="docutils literal notranslate"><span class="pre">value_type</span></code> alias member </p></li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code>: - const reference to a collection from which data will be copied to the <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dims</span></code>: - dimensions of the <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt">
<span id="_CPPv3I00EN3LLU6Tensor6TensorE7InputIt7InputIt"></span><span id="_CPPv2I00EN3LLU6Tensor6TensorE7InputIt7InputIt"></span>template&lt;class <code class="sig-name descname">InputIt</code>, typename = enable_if_input_iterator&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt" title="LLU::Tensor::Tensor::InputIt">InputIt</a>&gt;&gt;<br /><span class="target" id="classLLU_1_1Tensor_1a61ad3f3f252258317a86d28293a6777d"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt" title="LLU::Tensor::Tensor::InputIt">InputIt</a> <em>first</em>, <a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt" title="LLU::Tensor::Tensor::InputIt">InputIt</a> <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs flat <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> with elements from range [first, last) </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">first</span></code>: - iterator to the beginning of range </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">last</span></code>: - iterator past the end of range </p></li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">InputIt</span></code>: - any iterator conforming to InputIterator concept </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">see</span></code>: Tensor&lt;T&gt;::Tensor(InputIt, InputIt, std::initializer_list&lt;mint&gt;)</p></li>
</ul>
</dd>
<dt><strong>Warning</strong></dt><dd><p>It is user’s responsibility to make sure that length of range fits into mint! </p>
</dd>
<dt><strong>Note</strong></dt><dd><p>Be aware that efficiency of this constructor strongly depends on whether the InputIt is also a RandomAccessIterator </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor6TensorE1T16MArrayDimensions">
<span id="_CPPv3N3LLU6Tensor6TensorE1T16MArrayDimensions"></span><span id="_CPPv2N3LLU6Tensor6TensorE1T16MArrayDimensions"></span><span id="LLU::Tensor::Tensor__T.MArrayDimensions"></span><span class="target" id="classLLU_1_1Tensor_1a63ed5fe8c8ef9e2403d145749863f81f"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a> <em>init</em>, MArrayDimensions <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6Tensor6TensorE1T16MArrayDimensions" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs the <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> of given shape with all elements initialized to given value. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">init</span></code>: - value of type <strong>T</strong> to initialize all elements of the <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">dims</span></code>: - MArrayDimensions object with <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> dimensions </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt16MArrayDimensions">
<span id="_CPPv3I00EN3LLU6Tensor6TensorE7InputIt7InputIt16MArrayDimensions"></span><span id="_CPPv2I00EN3LLU6Tensor6TensorE7InputIt7InputIt16MArrayDimensions"></span>template&lt;class <code class="sig-name descname">InputIt</code>, typename = enable_if_input_iterator&lt;<a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt16MArrayDimensions" title="LLU::Tensor::Tensor::InputIt">InputIt</a>&gt;&gt;<br /><span class="target" id="classLLU_1_1Tensor_1a67178f4d6d85b8882a2540e47744f10a"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt16MArrayDimensions" title="LLU::Tensor::Tensor::InputIt">InputIt</a> <em>first</em>, <a class="reference internal" href="#_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt16MArrayDimensions" title="LLU::Tensor::Tensor::InputIt">InputIt</a> <em>last</em>, MArrayDimensions <em>dims</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN3LLU6Tensor6TensorE7InputIt7InputIt16MArrayDimensions" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs the <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> of given shape with elements from range [first, last) </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">first</span></code>: - iterator to the beginning of range </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">last</span></code>: - iterator past the end of range </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">dims</span></code>: - container with <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> dimensions </p></li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">InputIt</span></code>: - any iterator conforming to InputIterator concept </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::TensorNewError</span></code>: - if number of elements in <code class="docutils literal notranslate"><span class="pre">v</span></code> does not match total <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> size indicated by <code class="docutils literal notranslate"><span class="pre">dims</span></code> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor6TensorE7MTensor9Ownership">
<span id="_CPPv3N3LLU6Tensor6TensorE7MTensor9Ownership"></span><span id="_CPPv2N3LLU6Tensor6TensorE7MTensor9Ownership"></span><span id="LLU::Tensor::Tensor__MTensor.Ownership"></span><span class="target" id="classLLU_1_1Tensor_1a2b60f2d746fa7378cc60af3ac541f4f8"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span>MTensor <em>t</em>, <a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6Tensor6TensorE7MTensor9Ownership" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> based on MTensor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">t</span></code>: - LibraryLink structure to be wrapped </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">owner</span></code>: - who manages the memory the raw MTensor </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::TensorTypeError</span></code>: - if the <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> template type <strong>T</strong> does not match the actual data type of the MTensor </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor6TensorE13GenericTensor">
<span id="_CPPv3N3LLU6Tensor6TensorE13GenericTensor"></span><span id="_CPPv2N3LLU6Tensor6TensorE13GenericTensor"></span><span id="LLU::Tensor::Tensor__GenericTensor"></span><span class="target" id="classLLU_1_1Tensor_1addd9cfd8df9fdd4d381bce1e6f12ac8c"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6Tensor6TensorE13GenericTensor" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create new <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> from a GenericTensor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">t</span></code>: - generic <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> to be wrapped into <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> class </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::TensorTypeError</span></code>: - if the <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> template type <strong>T</strong> does not match the actual data type of the generic <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor6TensorEv">
<span id="_CPPv3N3LLU6Tensor6TensorEv"></span><span id="_CPPv2N3LLU6Tensor6TensorEv"></span><span id="LLU::Tensor::Tensor"></span><span class="target" id="classLLU_1_1Tensor_1ad2d3bc56cad6c5d4939cee7e16a52c58"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N3LLU6Tensor6TensorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default constructor, creates a <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> that does not wrap over any raw MTensor. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor5cloneEv">
<span id="_CPPv3NK3LLU6Tensor5cloneEv"></span><span id="_CPPv2NK3LLU6Tensor5cloneEv"></span><span id="LLU::Tensor::cloneC"></span><span class="target" id="classLLU_1_1Tensor_1a13737a6c793f0589d0e42edb04db2c62"></span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a> <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a>, performing a deep copy of the underlying MTensor. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned MTensor always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new <a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor4rankEv">
<span id="_CPPv3NK3LLU6Tensor4rankEv"></span><span id="_CPPv2NK3LLU6Tensor4rankEv"></span><span id="LLU::Tensor::rankC"></span><span class="target" id="classLLU_1_1MArray_1a6a1f85549f320f4ccce4b8957495851a"></span>mint <code class="sig-name descname">rank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor4rankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get container rank. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor5emptyEv">
<span id="_CPPv3NK3LLU6Tensor5emptyEv"></span><span id="_CPPv2NK3LLU6Tensor5emptyEv"></span><span id="LLU::Tensor::emptyC"></span><span class="target" id="classLLU_1_1MArray_1ad0660a7856ffd2ebb931a75a09b7dca7"></span>bool <code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor5emptyEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check whether container is empty. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor9dimensionE4mint">
<span id="_CPPv3NK3LLU6Tensor9dimensionE4mint"></span><span id="_CPPv2NK3LLU6Tensor9dimensionE4mint"></span><span id="LLU::Tensor::dimension__mintC"></span><span class="target" id="classLLU_1_1MArray_1a44e07e472aa8c85ff60a7afcb005da71"></span>mint <code class="sig-name descname">dimension</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor9dimensionE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get dimension value at position <code class="docutils literal notranslate"><span class="pre">index</span></code>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor10dimensionsEv">
<span id="_CPPv3NK3LLU6Tensor10dimensionsEv"></span><span id="_CPPv2NK3LLU6Tensor10dimensionsEv"></span><span id="LLU::Tensor::dimensionsC"></span><span class="target" id="classLLU_1_1MArray_1aee9a5b13a2234e858a788cf917843814"></span><em class="property">const</em> MArrayDimensions &amp;<code class="sig-name descname">dimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor10dimensionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a const reference to dimensions object. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6TensorixERKNSt6vectorI4mintEE">
<span id="_CPPv3N3LLU6TensorixERKNSt6vectorI4mintEE"></span><span id="_CPPv2N3LLU6TensorixERKNSt6vectorI4mintEE"></span><span id="LLU::Tensor::subscript-operator__std::vector:mint:CR"></span><span class="target" id="classLLU_1_1MArray_1ad649b2993c695ce2b102f4138c7758f8"></span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a> &amp;<code class="sig-name descname">operator[]</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6TensorixERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6TensorixERKNSt6vectorI4mintEE">
<span id="_CPPv3NK3LLU6TensorixERKNSt6vectorI4mintEE"></span><span id="_CPPv2NK3LLU6TensorixERKNSt6vectorI4mintEE"></span><span id="LLU::Tensor::subscript-operator__std::vector:mint:CRC"></span><span class="target" id="classLLU_1_1MArray_1a22590ae040ce13a69fc6dcf1a7064aab"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a> &amp;<code class="sig-name descname">operator[]</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6TensorixERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6TensorixE4mint">
<span id="_CPPv3N3LLU6TensorixE4mint"></span><span id="_CPPv2N3LLU6TensorixE4mint"></span><span id="LLU::Tensor::subscript-operator__mint"></span><span class="target" id="classLLU_1_1IterableContainer_1a19a4221532b5d35e22b6573d46b87f80"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor9referenceE" title="LLU::Tensor::reference">reference</a> <code class="sig-name descname">operator[]</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6TensorixE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6TensorixE4mint">
<span id="_CPPv3NK3LLU6TensorixE4mint"></span><span id="_CPPv2NK3LLU6TensorixE4mint"></span><span id="LLU::Tensor::subscript-operator__mintC"></span><span class="target" id="classLLU_1_1IterableContainer_1a548d4460ce2474312c61ea7ad0b088f9"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor15const_referenceE" title="LLU::Tensor::const_reference">const_reference</a> <code class="sig-name descname">operator[]</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6TensorixE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor2atE4mint">
<span id="_CPPv3N3LLU6Tensor2atE4mint"></span><span id="_CPPv2N3LLU6Tensor2atE4mint"></span><span id="LLU::Tensor::at__mint"></span><span class="target" id="classLLU_1_1MArray_1a709e1c06e4891e210bca65c67cdbaad2"></span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6Tensor2atE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position with bound checking. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">index</span></code> is out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor2atE4mint">
<span id="_CPPv3NK3LLU6Tensor2atE4mint"></span><span id="_CPPv2NK3LLU6Tensor2atE4mint"></span><span id="LLU::Tensor::at__mintC"></span><span class="target" id="classLLU_1_1MArray_1a4eba03b34a730d7a372ebd4081409509"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span>mint <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor2atE4mint" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position with bound checking. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">index</span></code>: - position of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">index</span></code> is out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor2atERKNSt6vectorI4mintEE">
<span id="_CPPv3N3LLU6Tensor2atERKNSt6vectorI4mintEE"></span><span id="_CPPv2N3LLU6Tensor2atERKNSt6vectorI4mintEE"></span><span id="LLU::Tensor::at__std::vector:mint:CR"></span><span class="target" id="classLLU_1_1MArray_1a97b1d5b38f646fb55c0855699f648012"></span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6Tensor2atERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">indices</span></code> are out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor2atERKNSt6vectorI4mintEE">
<span id="_CPPv3NK3LLU6Tensor2atERKNSt6vectorI4mintEE"></span><span id="_CPPv2NK3LLU6Tensor2atERKNSt6vectorI4mintEE"></span><span id="LLU::Tensor::at__std::vector:mint:CRC"></span><span class="target" id="classLLU_1_1MArray_1a336ad439eabceff0ec49bcd01ff5e251"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor::T">T</a> &amp;<code class="sig-name descname">at</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;mint&gt; &amp;<em>indices</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor2atERKNSt6vectorI4mintEE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a constant reference to the data element at given position in a multidimensional container. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: - vector with coordinates of desired data element </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">indexError()</span></code>: - if <code class="docutils literal notranslate"><span class="pre">indices</span></code> are out-of-bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor4dataEv">
<span id="_CPPv3N3LLU6Tensor4dataEv"></span><span id="_CPPv2N3LLU6Tensor4dataEv"></span><span id="LLU::Tensor::data"></span><span class="target" id="classLLU_1_1IterableContainer_1a1f9294306bb0f09963859cbf5a395e4b"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor10value_typeE" title="LLU::Tensor::value_type">value_type</a> *<code class="sig-name descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU6Tensor4dataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get raw pointer to underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor4dataEv">
<span id="_CPPv3NK3LLU6Tensor4dataEv"></span><span id="_CPPv2NK3LLU6Tensor4dataEv"></span><span id="LLU::Tensor::dataC"></span><span class="target" id="classLLU_1_1IterableContainer_1ad074c86ef619bc6354b37018e7b55a18"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU6Tensor10value_typeE" title="LLU::Tensor::value_type">value_type</a> *<code class="sig-name descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor4dataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get raw pointer to const underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor4sizeEv">
<span id="_CPPv3NK3LLU6Tensor4sizeEv"></span><span id="_CPPv2NK3LLU6Tensor4sizeEv"></span><span id="LLU::Tensor::sizeC"></span><span class="target" id="classLLU_1_1IterableContainer_1ab3046c61f8bb0e1db83ec4907fbc5087"></span>mint <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor4sizeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get total number of elements in the container. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor5beginEv">
<span id="_CPPv3N3LLU6Tensor5beginEv"></span><span id="_CPPv2N3LLU6Tensor5beginEv"></span><span id="LLU::Tensor::begin"></span><span class="target" id="classLLU_1_1IterableContainer_1adbbf7628ba97cdb30fe78000d2b5fc20"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor8iteratorE" title="LLU::Tensor::iterator">iterator</a> <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU6Tensor5beginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor5beginEv">
<span id="_CPPv3NK3LLU6Tensor5beginEv"></span><span id="_CPPv2NK3LLU6Tensor5beginEv"></span><span id="LLU::Tensor::beginC"></span><span class="target" id="classLLU_1_1IterableContainer_1ac107dad385fa41d1853766bc6ef249ec"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor14const_iteratorE" title="LLU::Tensor::const_iterator">const_iterator</a> <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor5beginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor6cbeginEv">
<span id="_CPPv3NK3LLU6Tensor6cbeginEv"></span><span id="_CPPv2NK3LLU6Tensor6cbeginEv"></span><span id="LLU::Tensor::cbeginC"></span><span class="target" id="classLLU_1_1IterableContainer_1a58ec84224bf0e8ca8927e4553cb8afb8"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor14const_iteratorE" title="LLU::Tensor::const_iterator">const_iterator</a> <code class="sig-name descname">cbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor6cbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor3endEv">
<span id="_CPPv3N3LLU6Tensor3endEv"></span><span id="_CPPv2N3LLU6Tensor3endEv"></span><span id="LLU::Tensor::end"></span><span class="target" id="classLLU_1_1IterableContainer_1a9bd4ff608c8087acd4abae3df8c177e8"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor8iteratorE" title="LLU::Tensor::iterator">iterator</a> <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU6Tensor3endEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor3endEv">
<span id="_CPPv3NK3LLU6Tensor3endEv"></span><span id="_CPPv2NK3LLU6Tensor3endEv"></span><span id="LLU::Tensor::endC"></span><span class="target" id="classLLU_1_1IterableContainer_1af0164d7e75cc5b8c3ae7b7625e75ccbd"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor14const_iteratorE" title="LLU::Tensor::const_iterator">const_iterator</a> <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor3endEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor4cendEv">
<span id="_CPPv3NK3LLU6Tensor4cendEv"></span><span id="_CPPv2NK3LLU6Tensor4cendEv"></span><span id="LLU::Tensor::cendC"></span><span class="target" id="classLLU_1_1IterableContainer_1a5734bc636b9edca9dda9e7ac69c50d37"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor14const_iteratorE" title="LLU::Tensor::const_iterator">const_iterator</a> <code class="sig-name descname">cend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor4cendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor6rbeginEv">
<span id="_CPPv3N3LLU6Tensor6rbeginEv"></span><span id="_CPPv2N3LLU6Tensor6rbeginEv"></span><span id="LLU::Tensor::rbegin"></span><span class="target" id="classLLU_1_1IterableContainer_1a5d59ccc0e700a96c51045f0d5ee69883"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor16reverse_iteratorE" title="LLU::Tensor::reverse_iterator">reverse_iterator</a> <code class="sig-name descname">rbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU6Tensor6rbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor6rbeginEv">
<span id="_CPPv3NK3LLU6Tensor6rbeginEv"></span><span id="_CPPv2NK3LLU6Tensor6rbeginEv"></span><span id="LLU::Tensor::rbeginC"></span><span class="target" id="classLLU_1_1IterableContainer_1a177fe159a37bbaf8eb8546b26fb0f9e3"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor22const_reverse_iteratorE" title="LLU::Tensor::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">rbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor6rbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor7crbeginEv">
<span id="_CPPv3NK3LLU6Tensor7crbeginEv"></span><span id="_CPPv2NK3LLU6Tensor7crbeginEv"></span><span id="LLU::Tensor::crbeginC"></span><span class="target" id="classLLU_1_1IterableContainer_1a03798d561430d17054f801bcf4ca4510"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor22const_reverse_iteratorE" title="LLU::Tensor::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">crbegin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor7crbeginEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator at the beginning of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor4rendEv">
<span id="_CPPv3N3LLU6Tensor4rendEv"></span><span id="_CPPv2N3LLU6Tensor4rendEv"></span><span id="LLU::Tensor::rend"></span><span class="target" id="classLLU_1_1IterableContainer_1adc895d42aa8cb4e1fa3145eb9f83a5fb"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor16reverse_iteratorE" title="LLU::Tensor::reverse_iterator">reverse_iterator</a> <code class="sig-name descname">rend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU6Tensor4rendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor4rendEv">
<span id="_CPPv3NK3LLU6Tensor4rendEv"></span><span id="_CPPv2NK3LLU6Tensor4rendEv"></span><span id="LLU::Tensor::rendC"></span><span class="target" id="classLLU_1_1IterableContainer_1af053c33d89fc05f1c9368df1b6a5d00d"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor22const_reverse_iteratorE" title="LLU::Tensor::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">rend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor4rendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor5crendEv">
<span id="_CPPv3NK3LLU6Tensor5crendEv"></span><span id="_CPPv2NK3LLU6Tensor5crendEv"></span><span id="LLU::Tensor::crendC"></span><span class="target" id="classLLU_1_1IterableContainer_1ac6a8810748705c2359a379dab9f3c396"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor22const_reverse_iteratorE" title="LLU::Tensor::const_reverse_iterator">const_reverse_iterator</a> <code class="sig-name descname">crend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor5crendEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant iterator after the end of underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor5frontEv">
<span id="_CPPv3N3LLU6Tensor5frontEv"></span><span id="_CPPv2N3LLU6Tensor5frontEv"></span><span id="LLU::Tensor::front"></span><span class="target" id="classLLU_1_1IterableContainer_1af22c6027070c7fd150bb86a53d8f50de"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor9referenceE" title="LLU::Tensor::reference">reference</a> <code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6Tensor5frontEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get reference to the first element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor5frontEv">
<span id="_CPPv3NK3LLU6Tensor5frontEv"></span><span id="_CPPv2NK3LLU6Tensor5frontEv"></span><span id="LLU::Tensor::frontC"></span><span class="target" id="classLLU_1_1IterableContainer_1ad11d7f07a4e7ff56818d4b038646525d"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor15const_referenceE" title="LLU::Tensor::const_reference">const_reference</a> <code class="sig-name descname">front</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor5frontEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant reference to the first element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU6Tensor4backEv">
<span id="_CPPv3N3LLU6Tensor4backEv"></span><span id="_CPPv2N3LLU6Tensor4backEv"></span><span id="LLU::Tensor::back"></span><span class="target" id="classLLU_1_1IterableContainer_1abcde345515a1529d00d7f35bdd3c428e"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor9referenceE" title="LLU::Tensor::reference">reference</a> <code class="sig-name descname">back</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU6Tensor4backEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get reference to the last element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor4backEv">
<span id="_CPPv3NK3LLU6Tensor4backEv"></span><span id="_CPPv2NK3LLU6Tensor4backEv"></span><span id="LLU::Tensor::backC"></span><span class="target" id="classLLU_1_1IterableContainer_1a74006685a7c15be6030f7217d761280a"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor15const_referenceE" title="LLU::Tensor::const_reference">const_reference</a> <code class="sig-name descname">back</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor4backEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get constant reference to the last element. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>For empty container the behavior is undefined. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor8asVectorEv">
<span id="_CPPv3NK3LLU6Tensor8asVectorEv"></span><span id="_CPPv2NK3LLU6Tensor8asVectorEv"></span><span id="LLU::Tensor::asVectorC"></span><span class="target" id="classLLU_1_1IterableContainer_1af66aee992031feec7f2c41a50b71a8b6"></span>std::vector&lt;<a class="reference internal" href="#_CPPv4N3LLU6Tensor10value_typeE" title="LLU::Tensor::value_type">value_type</a>&gt; <code class="sig-name descname">asVector</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor8asVectorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Copy contents of the data to a std::vector of matching type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>std::vector with the copy of the data </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor7getRankEv">
<span id="_CPPv3NK3LLU6Tensor7getRankEv"></span><span id="_CPPv2NK3LLU6Tensor7getRankEv"></span><span id="LLU::Tensor::getRankC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1a08e3854d4989119c4bde754ee4e1e98d"></span>mint <code class="sig-name descname">getRank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor7getRankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get rank. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>number of dimensions in this tensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getRank.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getRank.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor13getDimensionsEv">
<span id="_CPPv3NK3LLU6Tensor13getDimensionsEv"></span><span id="_CPPv2NK3LLU6Tensor13getDimensionsEv"></span><span id="LLU::Tensor::getDimensionsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1a60f0ce5f03e79f7fb75f6637e2d22583"></span>mint <em class="property">const</em> *<code class="sig-name descname">getDimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor13getDimensionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get dimensions. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>raw pointer to dimensions of this tensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getDimensions.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getDimensions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor18getFlattenedLengthEv">
<span id="_CPPv3NK3LLU6Tensor18getFlattenedLengthEv"></span><span id="_CPPv2NK3LLU6Tensor18getFlattenedLengthEv"></span><span id="LLU::Tensor::getFlattenedLengthC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1ab9cf6ab9c75cb6e3518107adb08965d8"></span>mint <code class="sig-name descname">getFlattenedLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor18getFlattenedLengthEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get total length. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>total number of elements </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getFlattenedLength.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getFlattenedLength.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor4typeEv">
<span id="_CPPv3NK3LLU6Tensor4typeEv"></span><span id="_CPPv2NK3LLU6Tensor4typeEv"></span><span id="LLU::Tensor::typeC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1a5e5d2ed923a5edcd9301ed3e2fe654ec"></span>mint <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the data type of this tensor. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type of elements (MType_Integer, MType_Real or MType_Complex) </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getType.html">http://reference.wolfram.com/language/LibraryLink/ref/callback/MTensor_getType.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor7rawDataEv">
<span id="_CPPv3NK3LLU6Tensor7rawDataEv"></span><span id="_CPPv2NK3LLU6Tensor7rawDataEv"></span><span id="LLU::Tensor::rawDataC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4_1aa5c6718ea36d23638c0ca151f625a3b7"></span>void *<code class="sig-name descname">rawData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor7rawDataEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get raw pointer to the data of this tensor. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor12getContainerEv">
<span id="_CPPv3NK3LLU6Tensor12getContainerEv"></span><span id="_CPPv2NK3LLU6Tensor12getContainerEv"></span><span id="LLU::Tensor::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor9ContainerE" title="LLU::Tensor::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor16abandonContainerEv">
<span id="_CPPv3NK3LLU6Tensor16abandonContainerEv"></span><span id="_CPPv2NK3LLU6Tensor16abandonContainerEv"></span><span id="LLU::Tensor::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU6Tensor9ContainerE" title="LLU::Tensor::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor10shareCountEv">
<span id="_CPPv3NK3LLU6Tensor10shareCountEv"></span><span id="_CPPv2NK3LLU6Tensor10shareCountEv"></span><span id="LLU::Tensor::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor4passER9MArgument">
<span id="_CPPv3NK3LLU6Tensor4passER9MArgument"></span><span id="_CPPv2NK3LLU6Tensor4passER9MArgument"></span><span id="LLU::Tensor::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU6Tensor8getOwnerEv">
<span id="_CPPv3NK3LLU6Tensor8getOwnerEv"></span><span id="_CPPv2NK3LLU6Tensor8getOwnerEv"></span><span id="LLU::Tensor::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU6Tensor8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="llu-sparsearray-t">
<span id="spararr-label"></span><h3><a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::SparseArray&lt;T&gt;</span></code></a><a class="headerlink" href="#llu-sparsearray-t" title="Permalink to this headline"> 🔗</a></h3>
<p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">LLU</span><span class="pre">::</span><a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray"><span class="pre">SparseArray</span></a></code> is a wrapper over an MSparseArray which holds elements of type <code class="docutils literal notranslate"><span class="pre">T</span></code>. MSparseArray supports only 3 types of data,
meaning that <a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">template&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">LLU::SparseArray</span></code></a> class template can be instantiated with only 3 types <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mint</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::complex&lt;double&gt;</span></code></p></li>
</ul>
</div></blockquote>
<p>Here is an example of the SparseArray class in action:</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">sparseModifyValues</span><span class="p">(</span><span class="n">LLU</span><span class="o">::</span><span class="n">SparseArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">sa</span><span class="p">,</span> <span class="n">LLU</span><span class="o">::</span><span class="n">TensorTypedView</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">newValues</span><span class="p">)</span> <span class="p">{</span>

   <span class="c1">// extract a Tensor with explicit values of the SparseArray</span>
   <span class="c1">// this does not make a copy of the values so modifying the Tensor will modify the values in the SparseArray</span>
   <span class="k">auto</span> <span class="n">values</span> <span class="o">=</span> <span class="n">sa</span><span class="p">.</span><span class="n">explicitValues</span><span class="p">();</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">newValues</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
     <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span> <span class="p">{</span><span class="s">&quot;Too many values provided.&quot;</span><span class="p">};</span>
   <span class="p">}</span>

   <span class="c1">// copy new values in place of the old ones</span>
   <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">(</span><span class="n">newValues</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">(</span><span class="n">newValues</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">values</span><span class="p">));</span>

   <span class="c1">// Recompute explicit positions (necessary since one of the new values might be equal to the implicit value of the SparseArray)</span>
   <span class="n">sa</span><span class="p">.</span><span class="n">resparsify</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">LLU_LIBRARY_FUNCTION</span><span class="p">(</span><span class="n">ModifyValues</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">auto</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">mngr</span><span class="p">.</span><span class="n">getGenericSparseArray</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">Passing</span><span class="o">::</span><span class="n">Shared</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="k">auto</span> <span class="n">values</span> <span class="o">=</span> <span class="n">mngr</span><span class="p">.</span><span class="n">getGenericTensor</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">Passing</span><span class="o">::</span><span class="n">Constant</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

   <span class="c1">// Operate on the GenericSparseArray as if its type was known</span>
   <span class="n">LLU</span><span class="o">::</span><span class="n">asTypedSparseArray</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">values</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">sparseArray</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">sparseArray</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">;</span>
      <span class="n">sparseModifyValues</span><span class="p">(</span><span class="n">sparseArray</span><span class="p">,</span> <span class="n">LLU</span><span class="o">::</span><span class="n">TensorTypedView</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">values</span><span class="p">});</span>
   <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>On the Wolfram Language side, we can load and use this function as follows:</p>
<div class="highlight-wolfram-language notranslate"><div class="highlight"><pre><span></span><span class="c">(* Our function takes a shared SparseArray to modify it in-place. The SparseArray can be of any type. *)</span><span class="w"></span>
<span class="nv">`LLU`PacletFunctionSet</span><span class="p">[</span><span class="nv">$ModifyValues</span><span class="p">,</span><span class="w"> </span><span class="p">{{</span><span class="nb">LibraryDataType</span><span class="p">[</span><span class="nb">SparseArray</span><span class="p">,</span><span class="w"> </span><span class="o">_</span><span class="p">,</span><span class="w"> </span><span class="o">_</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;Shared&quot;</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="o">_</span><span class="p">,</span><span class="w"> </span><span class="o">_</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Constant&quot;</span><span class="p">}},</span><span class="w"> </span><span class="s">&quot;Void&quot;</span><span class="p">]</span><span class="o">;</span><span class="w"></span>

<span class="nv">sparse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">SparseArray</span><span class="p">[{{</span><span class="m">3.5</span><span class="p">,</span><span class="w"> </span><span class="m">0.</span><span class="p">,</span><span class="w"> </span><span class="m">0.</span><span class="p">,</span><span class="w"> </span><span class="m">0.</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="m">.5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="m">7.</span><span class="p">,</span><span class="w"> </span><span class="m">0.</span><span class="p">,</span><span class="w"> </span><span class="m">0.</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="m">4.</span><span class="p">,</span><span class="w"> </span><span class="m">0.</span><span class="p">,</span><span class="w"> </span><span class="m">3.</span><span class="p">,</span><span class="w"> </span><span class="m">0.</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="m">0.</span><span class="p">,</span><span class="w"> </span><span class="m">0.</span><span class="p">,</span><span class="w"> </span><span class="m">0.</span><span class="p">,</span><span class="w"> </span><span class="m">1.</span><span class="p">}}]</span><span class="o">;</span><span class="w"></span>
<span class="nv">$ModifyValues</span><span class="p">[</span><span class="nv">sparse</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="m">3.5</span><span class="p">,</span><span class="w"> </span><span class="m">.5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="m">7.</span><span class="p">}]</span><span class="o">;</span><span class="w"></span>
<span class="nb">Normal</span><span class="p">[</span><span class="nv">sparse</span><span class="p">]</span><span class="w"></span>

<span class="c">(* Out[] = {{3.5, 0., 0., 0.}, {.5, -7., 0., 0.}, {4., 0., 3., 0.}, {0., 0., 0., 1.}} *)</span><span class="w"></span>
</pre></div>
</div>
<dl class="cpp class">
<dt id="_CPPv4I0EN3LLU11SparseArrayE">
<span id="_CPPv3I0EN3LLU11SparseArrayE"></span><span id="_CPPv2I0EN3LLU11SparseArrayE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classLLU_1_1SparseArray"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">SparseArray</code> : <em class="property">public</em> LLU::<a class="reference internal" href="#_CPPv4IEN3LLU10MContainerIN13MArgumentType11SparseArrayEEE" title="LLU::MContainer&lt;MArgumentType::SparseArray&gt;">MContainer</a>&lt;MArgumentType::SparseArray&gt;<a class="headerlink" href="#_CPPv4I0EN3LLU11SparseArrayE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Strongly typed wrapper for MSparseArray. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: - any type supported by MSparseArray (mint, double or std::complex&lt;double&gt;) </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU11SparseArray9ContainerE">
<span id="_CPPv3N3LLU11SparseArray9ContainerE"></span><span id="_CPPv2N3LLU11SparseArray9ContainerE"></span><span class="target" id="classLLU_1_1MContainerBase_1a943d513079b8ae6999e3ee1762967366"></span><em class="property">using </em><code class="sig-name descname">Container</code> = Argument::CType&lt;Type&gt;<a class="headerlink" href="#_CPPv4N3LLU11SparseArray9ContainerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>The type of underlying LibraryLink structure (e.g. MTensor, MImage, etc.) will be called “Container”. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU11SparseArray11SparseArrayEv">
<span id="_CPPv3N3LLU11SparseArray11SparseArrayEv"></span><span id="_CPPv2N3LLU11SparseArray11SparseArrayEv"></span><span id="LLU::SparseArray::SparseArray"></span><span class="target" id="classLLU_1_1SparseArray_1a45d659b5c42910a4e133970429e68673"></span><code class="sig-name descname">SparseArray</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N3LLU11SparseArray11SparseArrayEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Default constructor, creates a <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> that does not wrap over any raw MSparseArray. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU11SparseArray11SparseArrayE12MSparseArray9Ownership">
<span id="_CPPv3N3LLU11SparseArray11SparseArrayE12MSparseArray9Ownership"></span><span id="_CPPv2N3LLU11SparseArray11SparseArrayE12MSparseArray9Ownership"></span><span id="LLU::SparseArray::SparseArray__MSparseArray.Ownership"></span><span class="target" id="classLLU_1_1SparseArray_1ac2172c4c1ffa83e546d556ef5d0c1e03"></span><code class="sig-name descname">SparseArray</code><span class="sig-paren">(</span>MSparseArray <em>t</em>, <a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU11SparseArray11SparseArrayE12MSparseArray9Ownership" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Constructs <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> based on MSparseArray. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">t</span></code>: - LibraryLink structure to be wrapped </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">owner</span></code>: - who manages the memory the raw MSparseArray </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::SparseArrayTypeError</span></code>: - if the <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> template type <strong>T</strong> does not match the actual data type of the MSparseArray </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU11SparseArray11SparseArrayE18GenericSparseArray">
<span id="_CPPv3N3LLU11SparseArray11SparseArrayE18GenericSparseArray"></span><span id="_CPPv2N3LLU11SparseArray11SparseArrayE18GenericSparseArray"></span><span id="LLU::SparseArray::SparseArray__GenericSparseArray"></span><span class="target" id="classLLU_1_1SparseArray_1a18e4fa4f7426317a18c155497f07c687"></span><code class="sig-name descname">SparseArray</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N3LLU18GenericSparseArrayE" title="LLU::GenericSparseArray">GenericSparseArray</a> <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU11SparseArray11SparseArrayE18GenericSparseArray" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> from a GenericSparseArray. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">t</span></code>: - generic <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> to be wrapped into <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> class </p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ErrorName::SparseArrayTypeError</span></code>: - if the <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> template type <strong>T</strong> does not match the actual data type of the generic <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU11SparseArray11SparseArrayERK6TensorI4mintERK6TensorI1TERK6TensorI4mintE1T">
<span id="_CPPv3N3LLU11SparseArray11SparseArrayERK6TensorI4mintERK6TensorI1TERK6TensorI4mintE1T"></span><span id="_CPPv2N3LLU11SparseArray11SparseArrayERK6TensorI4mintERK6TensorI1TERK6TensorI4mintE1T"></span><span id="LLU::SparseArray::SparseArray__Tensor:mint:CR.Tensor:T:CR.Tensor:mint:CR.T"></span><span class="target" id="classLLU_1_1SparseArray_1a2c67ecc43a7cef9d498f15aae14a47a9"></span><code class="sig-name descname">SparseArray</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a>&lt;mint&gt; &amp;<em>positions</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a>&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray::T">T</a>&gt; &amp;<em>values</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a>&lt;mint&gt; &amp;<em>dimensions</em>, <a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray::T">T</a> <em>implicitValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU11SparseArray11SparseArrayERK6TensorI4mintERK6TensorI1TERK6TensorI4mintE1T" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> from positions, values, dimensions and an implicit value. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">positions</span></code>: - positions of all the explicit values in the array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">values</span></code>: - explicit values to be stored in the array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dimensions</span></code>: - dimensions of the new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">implicitValue</span></code>: - implicit value (the one that is not stored) of the new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
</ul>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_fromExplicitPositions.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_fromExplicitPositions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU11SparseArray11SparseArrayERK6TensorI1TE1T">
<span id="_CPPv3N3LLU11SparseArray11SparseArrayERK6TensorI1TE1T"></span><span id="_CPPv2N3LLU11SparseArray11SparseArrayERK6TensorI1TE1T"></span><span id="LLU::SparseArray::SparseArray__Tensor:T:CR.T"></span><span class="target" id="classLLU_1_1SparseArray_1a723331db0c213318bb8886f1597f681b"></span><code class="sig-name descname">SparseArray</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a>&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray::T">T</a>&gt; &amp;<em>data</em>, <a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray::T">T</a> <em>implicitValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU11SparseArray11SparseArrayERK6TensorI1TE1T" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> from data array and an implicit value. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: - a tensor whose contents will be copied and sparsified </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">implicitValue</span></code>: - implicit value (the one that is not stored) of the new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
</ul>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_fromMTensor.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_fromMTensor.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU11SparseArray11SparseArrayERK11SparseArray1T">
<span id="_CPPv3N3LLU11SparseArray11SparseArrayERK11SparseArray1T"></span><span id="_CPPv2N3LLU11SparseArray11SparseArrayERK11SparseArray1T"></span><span id="LLU::SparseArray::SparseArray__SparseArrayCR.T"></span><span class="target" id="classLLU_1_1SparseArray_1a6da08f16e612bab2edaf56990dccba13"></span><code class="sig-name descname">SparseArray</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU11SparseArray11SparseArrayERK11SparseArray1T" title="LLU::SparseArray::SparseArray">SparseArray</a> &amp;<em>s</em>, <a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray::T">T</a> <em>implicitValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU11SparseArray11SparseArrayERK11SparseArray1T" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create a copy of given <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> with different implicit value. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code>: - other <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> of type T </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">implicitValue</span></code>: - implicit value (the one that is not stored) of the new <a class="reference internal" href="#classLLU_1_1SparseArray"><span class="std std-ref">SparseArray</span></a> </p></li>
</ul>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray4rankEv">
<span id="_CPPv3NK3LLU11SparseArray4rankEv"></span><span id="_CPPv2NK3LLU11SparseArray4rankEv"></span><span id="LLU::SparseArray::rankC"></span><span class="target" id="classLLU_1_1SparseArray_1a07f23c98152f91c2fa8868e7f92aeb96"></span>mint <code class="sig-name descname">rank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray4rankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the rank (number of dimensions) of this sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the rank of this array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRank.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRank.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray13implicitValueEv">
<span id="_CPPv3NK3LLU11SparseArray13implicitValueEv"></span><span id="_CPPv2NK3LLU11SparseArray13implicitValueEv"></span><span id="LLU::SparseArray::implicitValueC"></span><span class="target" id="classLLU_1_1SparseArray_1a85682e4d014275da730877ca1b4087e3"></span><a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray::T">T</a> <code class="sig-name descname">implicitValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray13implicitValueEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the implicit value of this sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>implicit value (the one that is not stored) </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getImplicitValue.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getImplicitValue.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU11SparseArray16setImplicitValueE1T">
<span id="_CPPv3N3LLU11SparseArray16setImplicitValueE1T"></span><span id="_CPPv2N3LLU11SparseArray16setImplicitValueE1T"></span><span id="LLU::SparseArray::setImplicitValue__T"></span><span class="target" id="classLLU_1_1SparseArray_1a5a094f1b5ce31c437d567654713ed70f"></span>void <code class="sig-name descname">setImplicitValue</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray::T">T</a> <em>newImplicitValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU11SparseArray16setImplicitValueE1T" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Change the implicit value of this array. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">newImplicitValue</span></code>: - new implicit value </p></li>
</ul>
</dd>
<dt><strong>Note</strong></dt><dd><p>The underlying MSparseArray object may be replaced in the process. </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray14explicitValuesEv">
<span id="_CPPv3NK3LLU11SparseArray14explicitValuesEv"></span><span id="_CPPv2NK3LLU11SparseArray14explicitValuesEv"></span><span id="LLU::SparseArray::explicitValuesC"></span><span class="target" id="classLLU_1_1SparseArray_1aae8869e888d0e001b6529c3ef86c7b23"></span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a>&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray::T">T</a>&gt; <code class="sig-name descname">explicitValues</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray14explicitValuesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a tensor with the values corresponding to the explicitly stored positions in the sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> of rank 1 with length equal to the number of explicit positions in the array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitValues.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitValues.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray11rowPointersEv">
<span id="_CPPv3NK3LLU11SparseArray11rowPointersEv"></span><span id="_CPPv2NK3LLU11SparseArray11rowPointersEv"></span><span id="LLU::SparseArray::rowPointersC"></span><span class="target" id="classLLU_1_1SparseArray_1a9fdd5b17202c3e19a3ec13e0f37a99fc"></span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a>&lt;mint&gt; <code class="sig-name descname">rowPointers</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray11rowPointersEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a row pointer array for this sparse array. </p>
<p>The values returned are the cumulative number of explicitly represented elements for each row, so the values will be non-decreasing. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> of integers of rank 1 </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRowPointers.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRowPointers.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray13columnIndicesEv">
<span id="_CPPv3NK3LLU11SparseArray13columnIndicesEv"></span><span id="_CPPv2NK3LLU11SparseArray13columnIndicesEv"></span><span id="LLU::SparseArray::columnIndicesC"></span><span class="target" id="classLLU_1_1SparseArray_1aa74bb46c7f82a79bd8f3533318c7b666"></span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a>&lt;mint&gt; <code class="sig-name descname">columnIndices</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray13columnIndicesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the column indices for the explicitly stored positions in this sparse array. </p>
<p>The first dimension of the resulting tensor is the number of explicit positions, and the second dimension is equal to <a class="reference internal" href="#classLLU_1_1SparseArray_1a07f23c98152f91c2fa8868e7f92aeb96"><span class="std std-ref">rank()</span></a> - 1. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> of rank 2 </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getColumnIndices.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getColumnIndices.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray17explicitPositionsEv">
<span id="_CPPv3NK3LLU11SparseArray17explicitPositionsEv"></span><span id="_CPPv2NK3LLU11SparseArray17explicitPositionsEv"></span><span id="LLU::SparseArray::explicitPositionsC"></span><span class="target" id="classLLU_1_1SparseArray_1a6b539e1099e1a926fbfcaad0341af425"></span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a>&lt;mint&gt; <code class="sig-name descname">explicitPositions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray17explicitPositionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the explicitly specified positions in this sparse array. </p>
<p>The first dimension of the resulting tensor is the number of explicit positions, and the second dimension is equal to <a class="reference internal" href="#classLLU_1_1SparseArray_1a07f23c98152f91c2fa8868e7f92aeb96"><span class="std std-ref">rank()</span></a>. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> of rank 2 </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitPositions.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitPositions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray8toTensorEv">
<span id="_CPPv3NK3LLU11SparseArray8toTensorEv"></span><span id="_CPPv2NK3LLU11SparseArray8toTensorEv"></span><span id="LLU::SparseArray::toTensorC"></span><span class="target" id="classLLU_1_1SparseArray_1aacf252c02c250652576296ab20d47616"></span><a class="reference internal" href="#_CPPv4I0EN3LLU6TensorE" title="LLU::Tensor">Tensor</a>&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU11SparseArrayE" title="LLU::SparseArray::T">T</a>&gt; <code class="sig-name descname">toTensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray8toTensorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Expand this sparse array to a regular tensor. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="#classLLU_1_1Tensor"><span class="std std-ref">Tensor</span></a> of the same data type as this array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_toMTensor.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_toMTensor.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray5cloneEv">
<span id="_CPPv3NK3LLU11SparseArray5cloneEv"></span><span id="_CPPv2NK3LLU11SparseArray5cloneEv"></span><span id="LLU::SparseArray::cloneC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a7f423c613bec0591ff269abbebe255f5"></span>MContainer <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray5cloneEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Clone this MContainer, performs a deep copy of the underlying MSparseArray. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The cloned MContainer always belongs to the library (<a class="reference internal" href="#namespaceLLU_1a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"><span class="std std-ref">Ownership::Library</span></a>) because LibraryLink has no idea of its existence. </p>
</dd>
<dt><strong>Return</strong></dt><dd><p>new MContainer, by value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray24getImplicitValueAsTensorEv">
<span id="_CPPv3NK3LLU11SparseArray24getImplicitValueAsTensorEv"></span><span id="_CPPv2NK3LLU11SparseArray24getImplicitValueAsTensorEv"></span><span id="LLU::SparseArray::getImplicitValueAsTensorC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a9a211070a2972d586240f486f8c733c5"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getImplicitValueAsTensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray24getImplicitValueAsTensorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the implicit value of this sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Rank 0 tensor of the same type as the value type of this sparse array. </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getImplicitValue.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getImplicitValue.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU11SparseArray26setImplicitValueFromTensorERK13GenericTensor">
<span id="_CPPv3N3LLU11SparseArray26setImplicitValueFromTensorERK13GenericTensor"></span><span id="_CPPv2N3LLU11SparseArray26setImplicitValueFromTensorERK13GenericTensor"></span><span id="LLU::SparseArray::setImplicitValueFromTensor__GenericTensorCR"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1af4c1d6ed5edb883231438720e1ba684a"></span>void <code class="sig-name descname">setImplicitValueFromTensor</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> &amp;<em>implicitValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU11SparseArray26setImplicitValueFromTensorERK13GenericTensor" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Change the implicit value of this array. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">implicitValue</span></code>: - new implicit value </p></li>
</ul>
</dd>
<dt><strong>Note</strong></dt><dd><p>The underlying MSparseArray object may be replaced in the process. </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_resetImplicitValue.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray7getRankEv">
<span id="_CPPv3NK3LLU11SparseArray7getRankEv"></span><span id="_CPPv2NK3LLU11SparseArray7getRankEv"></span><span id="LLU::SparseArray::getRankC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a880c657eea250c0077a657b8df2da063"></span>mint <code class="sig-name descname">getRank</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray7getRankEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the rank (number of dimensions) of this sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the rank of this array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRank.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRank.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray13getDimensionsEv">
<span id="_CPPv3NK3LLU11SparseArray13getDimensionsEv"></span><span id="_CPPv2NK3LLU11SparseArray13getDimensionsEv"></span><span id="LLU::SparseArray::getDimensionsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1abd78772083eaa3e033714248fb872784"></span>mint <em class="property">const</em> *<code class="sig-name descname">getDimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray13getDimensionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get dimensions of this sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a read-only raw array of container dimensions </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getDimensions.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getDimensions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray17getExplicitValuesEv">
<span id="_CPPv3NK3LLU11SparseArray17getExplicitValuesEv"></span><span id="_CPPv2NK3LLU11SparseArray17getExplicitValuesEv"></span><span id="LLU::SparseArray::getExplicitValuesC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a56278e459d84d58ee0efeac1d9c0e5b5"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getExplicitValues</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray17getExplicitValuesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a tensor with the values corresponding to the explicitly stored positions in the sparse array. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of rank 1 with length equal to the number of explicit positions in the array or an empty wrapper for “pattern sparse arrays” </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitValues.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitValues.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray14getRowPointersEv">
<span id="_CPPv3NK3LLU11SparseArray14getRowPointersEv"></span><span id="_CPPv2NK3LLU11SparseArray14getRowPointersEv"></span><span id="LLU::SparseArray::getRowPointersC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1ab7089de352a7d13d76b0c494a88755e5"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getRowPointers</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray14getRowPointersEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get a row pointer array for this sparse array. </p>
<p>The values returned are the cumulative number of explicitly represented elements for each row, so the values will be non-decreasing. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of rank 1 and integer type or an empty GenericTensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRowPointers.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getRowPointers.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray16getColumnIndicesEv">
<span id="_CPPv3NK3LLU11SparseArray16getColumnIndicesEv"></span><span id="_CPPv2NK3LLU11SparseArray16getColumnIndicesEv"></span><span id="LLU::SparseArray::getColumnIndicesC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a690a62b0cd980c2adeb008382b1bae48"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getColumnIndices</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray16getColumnIndicesEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the column indices for the explicitly stored positions in this sparse array. </p>
<p>The first dimension of the resulting tensor is the number of explicit positions, and the second dimension is equal to getRank() - 1. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of rank 2 or an empty GenericTensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getColumnIndices.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getColumnIndices.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray20getExplicitPositionsEv">
<span id="_CPPv3NK3LLU11SparseArray20getExplicitPositionsEv"></span><span id="_CPPv2NK3LLU11SparseArray20getExplicitPositionsEv"></span><span id="LLU::SparseArray::getExplicitPositionsC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a0fb907eddff087c964f195177a274290"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">getExplicitPositions</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray20getExplicitPositionsEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the explicitly specified positions in this sparse array. </p>
<p>The first dimension of the resulting tensor is the number of explicit positions, and the second dimension is equal to getRank(). <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of rank 2 or an empty GenericTensor </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitPositions.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_getExplicitPositions.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray15toGenericTensorEv">
<span id="_CPPv3NK3LLU11SparseArray15toGenericTensorEv"></span><span id="_CPPv2NK3LLU11SparseArray15toGenericTensorEv"></span><span id="LLU::SparseArray::toGenericTensorC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a87c738ddcd337995d1f68263dc640b13"></span><a class="reference internal" href="#_CPPv4N3LLU13GenericTensorE" title="LLU::GenericTensor">GenericTensor</a> <code class="sig-name descname">toGenericTensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray15toGenericTensorEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Expand this sparse array to a regular tensor. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>GenericTensor of the same data type as this array </p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference external" href="https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_toMTensor.html">https://reference.wolfram.com/language/LibraryLink/ref/callback/MSparseArray_toMTensor.html</a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU11SparseArray10resparsifyEv">
<span id="_CPPv3N3LLU11SparseArray10resparsifyEv"></span><span id="_CPPv2N3LLU11SparseArray10resparsifyEv"></span><span id="LLU::SparseArray::resparsify"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a10184d988f1d276133c24bd86209606d"></span>void <code class="sig-name descname">resparsify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU11SparseArray10resparsifyEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Use current implicit value to recalculate the sparse array after the data has been modified. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray4typeEv">
<span id="_CPPv3NK3LLU11SparseArray4typeEv"></span><span id="_CPPv2NK3LLU11SparseArray4typeEv"></span><span id="LLU::SparseArray::typeC"></span><span class="target" id="classLLU_1_1MContainer_3_01MArgumentType_1_1SparseArray_01_4_1a88f859c1e4dcc265f658f3bb7ad884c3"></span>mint <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the data type of this MSparseArray. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type of elements (MType_Integer, MType_Real or MType_Complex) </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray12getContainerEv">
<span id="_CPPv3NK3LLU11SparseArray12getContainerEv"></span><span id="_CPPv2NK3LLU11SparseArray12getContainerEv"></span><span id="LLU::SparseArray::getContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1ab8561bdf957227a53e43897a781aca2b"></span><a class="reference internal" href="#_CPPv4N3LLU11SparseArray9ContainerE" title="LLU::SparseArray::Container">Container</a> <code class="sig-name descname">getContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray12getContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get internal container. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray16abandonContainerEv">
<span id="_CPPv3NK3LLU11SparseArray16abandonContainerEv"></span><span id="_CPPv2NK3LLU11SparseArray16abandonContainerEv"></span><span id="LLU::SparseArray::abandonContainerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a7e78954325a22a380c5eb025bcadabe7"></span><a class="reference internal" href="#_CPPv4N3LLU11SparseArray9ContainerE" title="LLU::SparseArray::Container">Container</a> <code class="sig-name descname">abandonContainer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray16abandonContainerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Give a handle to internal container and stop owning it. </p>
<p>Should be used with caution as it may potentially result with resource leak.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a handle to the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray10shareCountEv">
<span id="_CPPv3NK3LLU11SparseArray10shareCountEv"></span><span id="_CPPv2NK3LLU11SparseArray10shareCountEv"></span><span id="LLU::SparseArray::shareCountC"></span><span class="target" id="classLLU_1_1MContainerBase_1a5fb3a6aff83465d2a4cc8a771a56324a"></span>mint <code class="sig-name descname">shareCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray10shareCountEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Return share count of internal container, if present and 0 otherwise. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray4passER9MArgument">
<span id="_CPPv3NK3LLU11SparseArray4passER9MArgument"></span><span id="_CPPv2NK3LLU11SparseArray4passER9MArgument"></span><span id="LLU::SparseArray::pass__MArgumentRC"></span><span class="target" id="classLLU_1_1MContainerBase_1ae48053120f40815eb7d6644415b3dcb7"></span>void <code class="sig-name descname">pass</code><span class="sig-paren">(</span>MArgument &amp;<em>res</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray4passER9MArgument" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pass the internal container as result of a LibraryLink function. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: - MArgument which will hold internal container of this MContainerBase </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU11SparseArray8getOwnerEv">
<span id="_CPPv3NK3LLU11SparseArray8getOwnerEv"></span><span id="_CPPv2NK3LLU11SparseArray8getOwnerEv"></span><span id="LLU::SparseArray::getOwnerC"></span><span class="target" id="classLLU_1_1MContainerBase_1a77c35fac504b0e4111607332ae0020b5"></span><a class="reference internal" href="#_CPPv4N3LLU9OwnershipE" title="LLU::Ownership">Ownership</a> <code class="sig-name descname">getOwner</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU11SparseArray8getOwnerEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get ownership information. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the owner of the internal container </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="iterators">
<h2>Iterators<a class="headerlink" href="#iterators" title="Permalink to this headline"> 🔗</a></h2>
<p>All container classes in LLU are equipped with iterators. For Image, Tensor and NumericArray we get random-access iterators similar to those of, for instance,
<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">std</span><span class="pre">::</span><span class="pre">vector</span></code>, because these containers also allocate space for their data as a contiguous piece of memory. Reverse and constant iterators are
available as well.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Bear in mind that iterators for Image, Tensor and NumericArray are not aware of the container dimensions in the sense that the iteration happens in the
order in which data is laid out in memory. For 2D arrays this is often row-major order but it gets more complicated for multidimensional arrays
and for Images.</p>
</div>
<p>DataStore wrappers have different iterators, because DataStore has a list-like structure with nodes of type <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">DataStoreNode</span></code>. The list is
unidirectional, so reverse iterator is not available. The default iterator over GenericDataList, obtained with
<a class="reference internal" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE5beginEv" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::begin"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">begin</span></code></a> and <a class="reference internal" href="#_CPPv4NK3LLU10MContainerIN13MArgumentType9DataStoreEE3endEv" title="LLU::MContainer&lt;MArgumentType::DataStore&gt;::end"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">end</span></code></a>, is a proxy
iterator of type <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DataStoreIterator</span></code>.</p>
<dl class="cpp class">
<dt id="_CPPv4N3LLU17DataStoreIteratorE">
<span id="_CPPv3N3LLU17DataStoreIteratorE"></span><span id="_CPPv2N3LLU17DataStoreIteratorE"></span><span id="LLU::DataStoreIterator"></span><span class="target" id="classLLU_1_1DataStoreIterator"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">DataStoreIterator</code><a class="headerlink" href="#_CPPv4N3LLU17DataStoreIteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Proxy input iterator over DataStoreNodes, when dereferenced yields <a class="reference internal" href="#structLLU_1_1GenericDataNode"><span class="std std-ref">GenericDataNode</span></a> proxy objects. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU17DataStoreIterator10value_typeE">
<span id="_CPPv3N3LLU17DataStoreIterator10value_typeE"></span><span id="_CPPv2N3LLU17DataStoreIterator10value_typeE"></span><span class="target" id="classLLU_1_1DataStoreIterator_1acaebcf9efde8e1ce71d984ce9e5a8f0e"></span><em class="property">using </em><code class="sig-name descname">value_type</code> = <a class="reference internal" href="#_CPPv4N3LLU15GenericDataNodeE" title="LLU::GenericDataNode">GenericDataNode</a><a class="headerlink" href="#_CPPv4N3LLU17DataStoreIterator10value_typeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>This iterator returns proxy objects of type <a class="reference internal" href="#structLLU_1_1GenericDataNode"><span class="std std-ref">GenericDataNode</span></a>. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU17DataStoreIterator9referenceE">
<span id="_CPPv3N3LLU17DataStoreIterator9referenceE"></span><span id="_CPPv2N3LLU17DataStoreIterator9referenceE"></span><span class="target" id="classLLU_1_1DataStoreIterator_1a3fe89528be5b8f79afd9b129ab098165"></span><em class="property">using </em><code class="sig-name descname">reference</code> = <a class="reference internal" href="#_CPPv4N3LLU17DataStoreIterator10value_typeE" title="LLU::DataStoreIterator::value_type">value_type</a><a class="headerlink" href="#_CPPv4N3LLU17DataStoreIterator9referenceE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p><a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a> is a proxy iterator and so the reference type is the same as value_type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU17DataStoreIterator17iterator_categoryE">
<span id="_CPPv3N3LLU17DataStoreIterator17iterator_categoryE"></span><span id="_CPPv2N3LLU17DataStoreIterator17iterator_categoryE"></span><span class="target" id="classLLU_1_1DataStoreIterator_1a08463f3e89428d3101f1be0b27c7c5ef"></span><em class="property">using </em><code class="sig-name descname">iterator_category</code> = std::input_iterator_tag<a class="headerlink" href="#_CPPv4N3LLU17DataStoreIterator17iterator_categoryE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>As with all proxy iterators, <a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a> is only an input iterator. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU17DataStoreIterator7pointerE">
<span id="_CPPv3N3LLU17DataStoreIterator7pointerE"></span><span id="_CPPv2N3LLU17DataStoreIterator7pointerE"></span><span class="target" id="classLLU_1_1DataStoreIterator_1a6c6b3a7e05eea0c056f22b17b3fcc7c6"></span><em class="property">using </em><code class="sig-name descname">pointer</code> = <a class="reference internal" href="#_CPPv4N3LLU17DataStoreIterator10value_typeE" title="LLU::DataStoreIterator::value_type">value_type</a><a class="headerlink" href="#_CPPv4N3LLU17DataStoreIterator7pointerE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p><a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a> is a proxy iterator and so the pointer type is the same as value_type. </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU17DataStoreIterator15difference_typeE">
<span id="_CPPv3N3LLU17DataStoreIterator15difference_typeE"></span><span id="_CPPv2N3LLU17DataStoreIterator15difference_typeE"></span><span class="target" id="classLLU_1_1DataStoreIterator_1a8ebcb6b15f5f6a6c581a9e05f3c24d14"></span><em class="property">using </em><code class="sig-name descname">difference_type</code> = mint<a class="headerlink" href="#_CPPv4N3LLU17DataStoreIterator15difference_typeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Provide difference_type as required for input iterators. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU17DataStoreIterator17DataStoreIteratorE13DataStoreNode">
<span id="_CPPv3N3LLU17DataStoreIterator17DataStoreIteratorE13DataStoreNode"></span><span id="_CPPv2N3LLU17DataStoreIterator17DataStoreIteratorE13DataStoreNode"></span><span id="LLU::DataStoreIterator::DataStoreIterator__DataStoreNode"></span><span class="target" id="classLLU_1_1DataStoreIterator_1a7acd323f5bf3463caac18189a6a29744"></span><code class="sig-name descname">DataStoreIterator</code><span class="sig-paren">(</span>DataStoreNode <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU17DataStoreIterator17DataStoreIteratorE13DataStoreNode" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create a <a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a> pointing to a given node. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU17DataStoreIteratormlEv">
<span id="_CPPv3NK3LLU17DataStoreIteratormlEv"></span><span id="_CPPv2NK3LLU17DataStoreIteratormlEv"></span><span id="LLU::DataStoreIterator::mul-operatorC"></span><span class="target" id="classLLU_1_1DataStoreIterator_1aae0a3ab56c7f3b6f83c8af55126590dc"></span><a class="reference internal" href="#_CPPv4N3LLU17DataStoreIterator9referenceE" title="LLU::DataStoreIterator::reference">reference</a> <code class="sig-name descname">operator*</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU17DataStoreIteratormlEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get proxy object of the current node. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>proxy object of current node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU17DataStoreIteratorptEv">
<span id="_CPPv3NK3LLU17DataStoreIteratorptEv"></span><span id="_CPPv2NK3LLU17DataStoreIteratorptEv"></span><span id="LLU::DataStoreIterator::pointer-operatorC"></span><span class="target" id="classLLU_1_1DataStoreIterator_1abdc1b3ba44cc6cbace21861f3264034a"></span><a class="reference internal" href="#_CPPv4N3LLU17DataStoreIterator7pointerE" title="LLU::DataStoreIterator::pointer">pointer</a> <code class="sig-name descname">operator-&gt;</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU17DataStoreIteratorptEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get proxy object of the current node. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>proxy object of current node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU17DataStoreIteratorppEv">
<span id="_CPPv3N3LLU17DataStoreIteratorppEv"></span><span id="_CPPv2N3LLU17DataStoreIteratorppEv"></span><span id="LLU::DataStoreIterator::inc-operator"></span><span class="target" id="classLLU_1_1DataStoreIterator_1affce05147294625f728e944dcc5e97bc"></span><a class="reference internal" href="#_CPPv4N3LLU17DataStoreIteratorE" title="LLU::DataStoreIterator">DataStoreIterator</a> &amp;<code class="sig-name descname">operator++</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU17DataStoreIteratorppEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pre-increment operator. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>this </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU17DataStoreIteratorppEi">
<span id="_CPPv3N3LLU17DataStoreIteratorppEi"></span><span id="_CPPv2N3LLU17DataStoreIteratorppEi"></span><span id="LLU::DataStoreIterator::inc-operator__i"></span><span class="target" id="classLLU_1_1DataStoreIterator_1aea9289a3468f2001154bbbf20257486c"></span><a class="reference internal" href="#_CPPv4N3LLU17DataStoreIteratorE" title="LLU::DataStoreIterator">DataStoreIterator</a> <code class="sig-name descname">operator++</code><span class="sig-paren">(</span>int<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU17DataStoreIteratorppEi" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Post-increment operator. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>”old” copy of the iterator object </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU17DataStoreIteratoreqERK17DataStoreIteratorRK17DataStoreIterator">
<span id="_CPPv3N3LLU17DataStoreIteratoreqERK17DataStoreIteratorRK17DataStoreIterator"></span><span id="_CPPv2N3LLU17DataStoreIteratoreqERK17DataStoreIteratorRK17DataStoreIterator"></span><span id="LLU::DataStoreIterator::eq-operator__DataStoreIteratorCR.DataStoreIteratorCR"></span><span class="target" id="classLLU_1_1DataStoreIterator_1ad290c9a1953a1d039bf703420721aebb"></span><em class="property">friend</em> bool <code class="sig-name descname">operator==</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU17DataStoreIteratorE" title="LLU::DataStoreIterator">DataStoreIterator</a> &amp;<em>lhs</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU17DataStoreIteratorE" title="LLU::DataStoreIterator">DataStoreIterator</a> &amp;<em>rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU17DataStoreIteratoreqERK17DataStoreIteratorRK17DataStoreIterator" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>“Equal to” operator for DataStoreIterators </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lhs</span></code>: - a <a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rhs</span></code>: - a <a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a> </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>true iff both iterators point to the same node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU17DataStoreIteratorneERK17DataStoreIteratorRK17DataStoreIterator">
<span id="_CPPv3N3LLU17DataStoreIteratorneERK17DataStoreIteratorRK17DataStoreIterator"></span><span id="_CPPv2N3LLU17DataStoreIteratorneERK17DataStoreIteratorRK17DataStoreIterator"></span><span id="LLU::DataStoreIterator::neq-operator__DataStoreIteratorCR.DataStoreIteratorCR"></span><span class="target" id="classLLU_1_1DataStoreIterator_1aa4730edad850e7ccbc29b688f74ebfbb"></span><em class="property">friend</em> bool <code class="sig-name descname">operator!=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU17DataStoreIteratorE" title="LLU::DataStoreIterator">DataStoreIterator</a> &amp;<em>lhs</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N3LLU17DataStoreIteratorE" title="LLU::DataStoreIterator">DataStoreIterator</a> &amp;<em>rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU17DataStoreIteratorneERK17DataStoreIteratorRK17DataStoreIterator" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>“Not equal to” operator for DataStoreIterators </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lhs</span></code>: - a <a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rhs</span></code>: - a <a class="reference internal" href="#classLLU_1_1DataStoreIterator"><span class="std std-ref">DataStoreIterator</span></a> </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>false iff both iterators point to the same node </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<p>The object obtained by dereferencing a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DataStoreIterator</span></code> is of type <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">GenericDataNode</span></code>.</p>
<dl class="cpp struct">
<dt id="_CPPv4N3LLU15GenericDataNodeE">
<span id="_CPPv3N3LLU15GenericDataNodeE"></span><span id="_CPPv2N3LLU15GenericDataNodeE"></span><span id="LLU::GenericDataNode"></span><span class="target" id="structLLU_1_1GenericDataNode"></span><em class="property">struct </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">GenericDataNode</code><a class="headerlink" href="#_CPPv4N3LLU15GenericDataNodeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Basic wrapper over DataStoreNode, provides class-like interface and conversion of the underlying value from MArgument to TypedArgument. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK3LLU15GenericDataNode4nextEv">
<span id="_CPPv3NK3LLU15GenericDataNode4nextEv"></span><span id="_CPPv2NK3LLU15GenericDataNode4nextEv"></span><span id="LLU::GenericDataNode::nextC"></span><span class="target" id="structLLU_1_1GenericDataNode_1a74574c61beaa779d5f4019f7f13491a1"></span><a class="reference internal" href="#_CPPv4N3LLU15GenericDataNodeE" title="LLU::GenericDataNode">GenericDataNode</a> <code class="sig-name descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU15GenericDataNode4nextEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get <a class="reference internal" href="#structLLU_1_1GenericDataNode"><span class="std std-ref">GenericDataNode</span></a> wrapper over the next node. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>next node wrapped in <a class="reference internal" href="#structLLU_1_1GenericDataNode"><span class="std std-ref">GenericDataNode</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU15GenericDataNode4typeEv">
<span id="_CPPv3NK3LLU15GenericDataNode4typeEv"></span><span id="_CPPv2NK3LLU15GenericDataNode4typeEv"></span><span id="LLU::GenericDataNode::typeC"></span><span class="target" id="structLLU_1_1GenericDataNode_1a5107ba605e501c89a37188ba67ecc3c9"></span>MArgumentType <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU15GenericDataNode4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get type of the node value. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>type of the node value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU15GenericDataNode4nameEv">
<span id="_CPPv3NK3LLU15GenericDataNode4nameEv"></span><span id="_CPPv2NK3LLU15GenericDataNode4nameEv"></span><span id="LLU::GenericDataNode::nameC"></span><span class="target" id="structLLU_1_1GenericDataNode_1a1a02d90fd6e6137eba2073076fc641ea"></span>std::string_view <code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4NK3LLU15GenericDataNode4nameEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get node name. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>string view over the name of the node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU15GenericDataNode5valueEv">
<span id="_CPPv3NK3LLU15GenericDataNode5valueEv"></span><span id="_CPPv2NK3LLU15GenericDataNode5valueEv"></span><span id="LLU::GenericDataNode::valueC"></span><span class="target" id="structLLU_1_1GenericDataNode_1aa4a9ee5c391f736f01f6813197f0de44"></span>Argument::TypedArgument <code class="sig-name descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU15GenericDataNode5valueEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get value of the node as the variant type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>TypedArgument variant holding the value of the node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0ENK3LLU15GenericDataNode2asE1Tv">
<span id="_CPPv3I0ENK3LLU15GenericDataNode2asEv"></span><span id="_CPPv2I0ENK3LLU15GenericDataNode2asEv"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="structLLU_1_1GenericDataNode_1a595dfaaf75e13f533774161f933f41dc"></span><a class="reference internal" href="#_CPPv4I0ENK3LLU15GenericDataNode2asE1Tv" title="LLU::GenericDataNode::as::T">T</a> <code class="sig-name descname">as</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4I0ENK3LLU15GenericDataNode2asE1Tv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get node value if it is of type T, otherwise throw an exception. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: - any type from LLU::NodeType namespace </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>node value of type T </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU15GenericDataNodecvbEv">
<span id="_CPPv3NK3LLU15GenericDataNodecvbEv"></span><span id="_CPPv2NK3LLU15GenericDataNodecvbEv"></span><span id="LLU::GenericDataNode::castto-b-operatorC"></span><span class="target" id="structLLU_1_1GenericDataNode_1a91f41a663a0a48616c581566b9cf77fd"></span><code class="sig-name descname">operator bool</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU15GenericDataNodecvbEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Bool conversion operator. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true iff the node is not null </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU15GenericDataNodeptEv">
<span id="_CPPv3N3LLU15GenericDataNodeptEv"></span><span id="_CPPv2N3LLU15GenericDataNodeptEv"></span><span id="LLU::GenericDataNode::pointer-operator"></span><span class="target" id="structLLU_1_1GenericDataNode_1ae48469f68cd3c57b535462c0a5d9b3d9"></span><a class="reference internal" href="#_CPPv4N3LLU15GenericDataNodeE" title="LLU::GenericDataNode">GenericDataNode</a> *<code class="sig-name descname">operator-&gt;</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU15GenericDataNodeptEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Member of pointer operator, used by <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> iterators. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="cpp var">
<dt id="_CPPv4N3LLU15GenericDataNode4nodeE">
<span id="_CPPv3N3LLU15GenericDataNode4nodeE"></span><span id="_CPPv2N3LLU15GenericDataNode4nodeE"></span><span id="LLU::GenericDataNode::node__DataStoreNode"></span><span class="target" id="structLLU_1_1GenericDataNode_1a003eb42c06b1ce3b0eb31c74b695ebde"></span>DataStoreNode <code class="sig-name descname">node</code><a class="headerlink" href="#_CPPv4N3LLU15GenericDataNode4nodeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Raw DataStore node. </p>
</dd></dl>

</div>
</dd></dl>

<p><a class="reference internal" href="#_CPPv4I0EN3LLU8DataListE" title="LLU::DataList"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LLU::DataList&lt;T&gt;</span></code></a> offers more types of iterators but again all of them are proxy iterators.
The default one is <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">NodeIterator</span></code></p>
<dl class="cpp struct">
<dt id="_CPPv4I0EN3LLU12NodeIteratorE">
<span id="_CPPv3I0EN3LLU12NodeIteratorE"></span><span id="_CPPv2I0EN3LLU12NodeIteratorE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="structLLU_1_1NodeIterator"></span><em class="property">struct </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">NodeIterator</code> : <em class="property">public</em> LLU::Detail::DataListIteratorPrimitive<a class="headerlink" href="#_CPPv4I0EN3LLU12NodeIteratorE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Simple proxy input iterator that goes over a DataStore and returns proxy DataNodes when dereferenced. </p>
<p><dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code>: - data node type, see LLU::NodeType namespace for supported node types </p></li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp type">
<dt id="_CPPv4N3LLU12NodeIterator10value_typeE">
<span id="_CPPv3N3LLU12NodeIterator10value_typeE"></span><span id="_CPPv2N3LLU12NodeIterator10value_typeE"></span><span class="target" id="structLLU_1_1NodeIterator_1a4677b8211447090d0846744b218032bb"></span><em class="property">using </em><code class="sig-name descname">value_type</code> = <a class="reference internal" href="#_CPPv4I0EN3LLU8DataNodeE" title="LLU::DataNode">DataNode</a>&lt;<a class="reference internal" href="#_CPPv4I0EN3LLU12NodeIteratorE" title="LLU::NodeIterator::T">T</a>&gt;<a class="headerlink" href="#_CPPv4N3LLU12NodeIterator10value_typeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>This iterator iterates over values of type DataNode&lt;T&gt; </p>
</dd></dl>

<dl class="cpp type">
<dt id="_CPPv4N3LLU12NodeIterator9referenceE">
<span id="_CPPv3N3LLU12NodeIterator9referenceE"></span><span id="_CPPv2N3LLU12NodeIterator9referenceE"></span><span class="target" id="structLLU_1_1NodeIterator_1a8073b95a880d179268174103dda70a40"></span><em class="property">using </em><code class="sig-name descname">reference</code> = <a class="reference internal" href="#_CPPv4N3LLU12NodeIterator10value_typeE" title="LLU::NodeIterator::value_type">value_type</a><a class="headerlink" href="#_CPPv4N3LLU12NodeIterator9referenceE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p><a class="reference internal" href="#structLLU_1_1NodeIterator"><span class="std std-ref">NodeIterator</span></a> is a proxy iterator and so the reference type is the same as value_type. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK3LLU12NodeIteratormlEv">
<span id="_CPPv3NK3LLU12NodeIteratormlEv"></span><span id="_CPPv2NK3LLU12NodeIteratormlEv"></span><span id="LLU::NodeIterator::mul-operatorC"></span><span class="target" id="structLLU_1_1NodeIterator_1ae5fcb191601198b5ee3a9ba479dc4604"></span><a class="reference internal" href="#_CPPv4N3LLU12NodeIterator9referenceE" title="LLU::NodeIterator::reference">reference</a> <code class="sig-name descname">operator*</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU12NodeIteratormlEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get current proxy <a class="reference internal" href="#classLLU_1_1DataNode"><span class="std std-ref">DataNode</span></a>. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>proxy object for the currently pointed to node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NodeIteratorppEv">
<span id="_CPPv3N3LLU12NodeIteratorppEv"></span><span id="_CPPv2N3LLU12NodeIteratorppEv"></span><span id="LLU::NodeIterator::inc-operator"></span><span class="target" id="structLLU_1_1NodeIterator_1a02ce9a44c33003b2dda1f6d0a4d946b6"></span><a class="reference internal" href="#_CPPv4I0EN3LLU12NodeIteratorE" title="LLU::NodeIterator">NodeIterator</a> &amp;<code class="sig-name descname">operator++</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NodeIteratorppEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Pre-increment operator. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>this </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU12NodeIteratorppEi">
<span id="_CPPv3N3LLU12NodeIteratorppEi"></span><span id="_CPPv2N3LLU12NodeIteratorppEi"></span><span id="LLU::NodeIterator::inc-operator__i"></span><span class="target" id="structLLU_1_1NodeIterator_1a1f714fdd60cf19d647cfa93b48012e21"></span><a class="reference internal" href="#_CPPv4I0EN3LLU12NodeIteratorE" title="LLU::NodeIterator">NodeIterator</a> <code class="sig-name descname">operator++</code><span class="sig-paren">(</span>int<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU12NodeIteratorppEi" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Post-increment operator. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>”old” copy of the iterator object </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<p>The object obtained by dereferencing a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">NodeIterator</span></code> is of type <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DataNode</span></code>.</p>
<dl class="cpp class">
<dt id="_CPPv4I0EN3LLU8DataNodeE">
<span id="_CPPv3I0EN3LLU8DataNodeE"></span><span id="_CPPv2I0EN3LLU8DataNodeE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classLLU_1_1DataNode"></span><em class="property">class </em><code class="sig-prename descclassname">LLU<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">DataNode</code><a class="headerlink" href="#_CPPv4I0EN3LLU8DataNodeE" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Wrapper over DataStoreNode structure from LibraryLink. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataNode8DataNodeE13DataStoreNode">
<span id="_CPPv3N3LLU8DataNode8DataNodeE13DataStoreNode"></span><span id="_CPPv2N3LLU8DataNode8DataNodeE13DataStoreNode"></span><span id="LLU::DataNode::DataNode__DataStoreNode"></span><span class="target" id="classLLU_1_1DataNode_1a69782f46bbce61a3a964cd57986279da"></span><code class="sig-name descname">DataNode</code><span class="sig-paren">(</span>DataStoreNode <em>dsn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataNode8DataNodeE13DataStoreNode" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create <a class="reference internal" href="#classLLU_1_1DataNode"><span class="std std-ref">DataNode</span></a> from raw DataStoreNode structure. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dsn</span></code>: - raw node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataNode8DataNodeE15GenericDataNode">
<span id="_CPPv3N3LLU8DataNode8DataNodeE15GenericDataNode"></span><span id="_CPPv2N3LLU8DataNode8DataNodeE15GenericDataNode"></span><span id="LLU::DataNode::DataNode__GenericDataNode"></span><span class="target" id="classLLU_1_1DataNode_1a4146b2a3526f591e68f8cc7488f7078f"></span><code class="sig-name descname">DataNode</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N3LLU15GenericDataNodeE" title="LLU::GenericDataNode">GenericDataNode</a> <em>gn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataNode8DataNodeE15GenericDataNode" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Create <a class="reference internal" href="#classLLU_1_1DataNode"><span class="std std-ref">DataNode</span></a> from raw <a class="reference internal" href="#structLLU_1_1GenericDataNode"><span class="std std-ref">GenericDataNode</span></a>. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gn</span></code>: - generic data node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataNode5valueEv">
<span id="_CPPv3N3LLU8DataNode5valueEv"></span><span id="_CPPv2N3LLU8DataNode5valueEv"></span><span id="LLU::DataNode::value"></span><span class="target" id="classLLU_1_1DataNode_1acab0aad841af432be6463a1ad4f0894f"></span><a class="reference internal" href="#_CPPv4I0EN3LLU8DataNodeE" title="LLU::DataNode::T">T</a> &amp;<code class="sig-name descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N3LLU8DataNode5valueEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get node value. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns a reference to node value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataNode5valueEv">
<span id="_CPPv3NK3LLU8DataNode5valueEv"></span><span id="_CPPv2NK3LLU8DataNode5valueEv"></span><span id="LLU::DataNode::valueC"></span><span class="target" id="classLLU_1_1DataNode_1a4dc5ada6e3e9c0fc7865ed558e89cb6f"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN3LLU8DataNodeE" title="LLU::DataNode::T">T</a> &amp;<code class="sig-name descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataNode5valueEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get node value. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns a reference to node value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataNode4nameEv">
<span id="_CPPv3NK3LLU8DataNode4nameEv"></span><span id="_CPPv2NK3LLU8DataNode4nameEv"></span><span id="LLU::DataNode::nameC"></span><span class="target" id="classLLU_1_1DataNode_1acfc1f79325aac4382b36040e3372f0dc"></span>std::string_view <code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataNode4nameEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get node name. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>string_view to the node name </p>
</dd>
<dt><strong>Note</strong></dt><dd><p>If you store the result of this function make sure it does not outlive the underlying DataStore node, otherwise make a string copy </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataNode7hasNextEv">
<span id="_CPPv3NK3LLU8DataNode7hasNextEv"></span><span id="_CPPv2NK3LLU8DataNode7hasNextEv"></span><span id="LLU::DataNode::hasNextC"></span><span class="target" id="classLLU_1_1DataNode_1a6ff6d883168d346d81df6345216545a6"></span>bool <code class="sig-name descname">hasNext</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataNode7hasNextEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Check if this node has a successor. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true iff the current node is not the last one in its <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK3LLU8DataNode4nextEv">
<span id="_CPPv3NK3LLU8DataNode4nextEv"></span><span id="_CPPv2NK3LLU8DataNode4nextEv"></span><span id="LLU::DataNode::nextC"></span><span class="target" id="classLLU_1_1DataNode_1ad2926bd7913a54c551d1a52e8db2d287"></span><a class="reference internal" href="#_CPPv4N3LLU15GenericDataNodeE" title="LLU::GenericDataNode">GenericDataNode</a> <code class="sig-name descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK3LLU8DataNode4nextEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get next node as <a class="reference internal" href="#structLLU_1_1GenericDataNode"><span class="std std-ref">GenericDataNode</span></a> (because the next node may not necessarily have value of type T) </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="#structLLU_1_1GenericDataNode"><span class="std std-ref">GenericDataNode</span></a> wrapper of next node, or empty if this is the last node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N3LLU8DataNode4typeEv">
<span id="_CPPv3N3LLU8DataNode4typeEv"></span><span id="_CPPv2N3LLU8DataNode4typeEv"></span><span id="LLU::DataNode::type"></span><span class="target" id="classLLU_1_1DataNode_1ac547d84fbe0fe6415072de02e9a80ac5"></span>MArgumentType <code class="sig-name descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N3LLU8DataNode4typeEv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get the actual type of node value. </p>
<p>This is useful when working on a “generic” <a class="reference internal" href="#classLLU_1_1DataList"><span class="std std-ref">DataList</span></a>. <dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Actual type of node value </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I_NSt6size_tEEN3LLU8DataNode3getEDcv">
<span id="_CPPv3I_NSt6size_tEEN3LLU8DataNode3getEv"></span><span id="_CPPv2I_NSt6size_tEEN3LLU8DataNode3getEv"></span>template&lt;std::size_t <code class="sig-name descname">N</code>&gt;<br /><span class="target" id="classLLU_1_1DataNode_1ae9c0b9098efac23c563e47259acd05e3"></span>decltype(auto) <code class="sig-name descname">get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I_NSt6size_tEEN3LLU8DataNode3getEDcv" title="Permalink to this definition"> 🔗</a><br /></dt>
<dd><p>Get N-th element of <a class="reference internal" href="#classLLU_1_1DataNode"><span class="std std-ref">DataNode</span></a> in a tuple-like way. </p>
<p>This function enables structured bindings to DataNodes. <dl class="simple">
<dt><strong>Template Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code>: - index (only 0 and 1 are valid) </p></li>
</ul>
</dd>
<dt><strong>Return</strong></dt><dd><p>either the node name for N == 0 or node value for N == 1 </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<p>Every data node has a (possibly empty) name and a value. Sometimes you might only be interested in node values, or only in names; DataList provides
specialized iterators for this. You may obtain them with <a class="reference internal" href="#_CPPv4NK3LLU8DataList10valueBeginEv" title="LLU::DataList::valueBegin"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">valueBegin()</span></code></a> and
<a class="reference internal" href="#_CPPv4NK3LLU8DataList9nameBeginEv" title="LLU::DataList::nameBegin"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nameBegin()</span></code></a>, respectively.</p>
<p>To get those specialized iterators in a range-based for loop, where you cannot directly choose which variant of <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">begin</span><span class="pre">(</span><span class="pre">)</span></code> method to use, you can
utilize one of the <em>iterator adaptors</em> that LLU defines. For instance,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get a DataList of complex numbers as argument to the library function</span>
<span class="k">auto</span> <span class="n">dataList</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getDataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">Complex</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// Create a new DataList to store node names of the original DataList as node values in the new list</span>
<span class="n">DataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">UTF8String</span><span class="o">&gt;</span> <span class="n">keys</span><span class="p">;</span>
<span class="hll"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">name</span> <span class="p">:</span> <span class="n">LLU</span><span class="o">::</span><span class="n">NameAdaptor</span> <span class="p">{</span><span class="n">dataList</span><span class="p">})</span> <span class="p">{</span>
</span>   <span class="n">keys</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Create a new DataList to store node values of the original DataList, without node names</span>
<span class="n">DataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">Complex</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
<span class="hll"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">value</span> <span class="p">:</span> <span class="n">LLU</span><span class="o">::</span><span class="n">ValueAdaptor</span> <span class="p">{</span><span class="n">dataList</span><span class="p">})</span> <span class="p">{</span>
</span>   <span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is possible to write the same code using the default iterator (<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">NodeIterator</span></code>) and structured bindings:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get a DataList of complex numbers as argument to the library function</span>
<span class="k">auto</span> <span class="n">dataList</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getDataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">Complex</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">DataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">UTF8String</span><span class="o">&gt;</span> <span class="n">keys</span><span class="p">;</span>
<span class="n">DataList</span><span class="o">&lt;</span><span class="n">LLU</span><span class="o">::</span><span class="n">NodeType</span><span class="o">::</span><span class="n">Complex</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>

<span class="c1">// Iterate over the dataList once, accessing both node name and value</span>
<span class="hll"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">:</span> <span class="n">dataList</span><span class="p">)</span> <span class="p">{</span>
</span>   <span class="n">keys</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
   <span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="error_handling.html" class="btn btn-neutral float-right" title="Error handling" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="functions.html" class="btn btn-neutral" title="Library functions" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Wolfram Research.
      Last updated on Aug 09, 2022.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> and ❤️  using a custom <a href="https://github.com/LinxiFan/Sphinx-theme">theme</a> based on <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'3.2.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="../_static/js/custom.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>